{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "60f73f47",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": "# Polynomial Bases and Transformations"
  },
  {
   "cell_type": "markdown",
   "id": "9250bb6bcb0da956",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "The Minterpy polynomials you've encountered so far have been represented in the Lagrange and Newton bases.\n",
    "Minterpy supports a range of polynomial bases, each with a consistent interface, meaning that polynomials in different bases behave and can be manipulated in similar ways.\n",
    "\n",
    "In this in-depth tutorial, you'll explore:\n",
    "\n",
    "- various polynomial bases supported by Minterpy\n",
    "- transformation between bases\n",
    "\n",
    "For simplicity, this tutorial uses examples in one and two dimensions, but the principles apply to polynomials of higher dimensions as well.\n",
    "\n",
    "Before diving in, make sure to import the necessary packages:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "df692690-ece7-408f-bf6a-38fec281b28f",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import minterpy as mp\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5460c3b2-003e-48c5-a089-d0360a000ea9",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "## Polynomials in Minterpy\n",
    "\n",
    "Polynomials in Minterpy are multidimensional polynomials defined on $[-1, 1]^m$ where $m$ is the spatial dimension:\n",
    "\n",
    "$$\n",
    "Q(\\boldsymbol{x}) = \\sum_{\\boldsymbol{\\alpha} \\in A} c_{\\cdot, \\boldsymbol{\\alpha}} \\Psi_{\\cdot, \\boldsymbol{\\alpha}} (\\boldsymbol{x}),\n",
    "$$\n",
    "\n",
    "where:\n",
    "\n",
    "- $A$ is the multi-index set of the exponents, i.e., $\\boldsymbol{\\alpha} \\in A \\subseteq \\mathbb{N}^m$ which generalizes the notion of polynomial degree to multiple dimensions.\n",
    "- $\\Psi_{\\cdot, \\boldsymbol{\\alpha}}$ is the multidimensional basis polynomial associated with the multi-index element $\\boldsymbol{\\alpha}$, the placeholder $\\cdot$ indicates that the basis polynomials depend on the chosen basis.\n",
    "- $c_{\\cdot, \\boldsymbol{\\alpha}}$ is the coefficient that corresponds to the multidimensional basis polynomial $\\Psi_{\\cdot, \\boldsymbol{\\alpha}}$.\n",
    "\n",
    "Minterpy supports several polynomial bases as shown in the table below.\n",
    "\n",
    "|            Basis            |                                       Constructor                                       |\n",
    "|:---------------------------:|:---------------------------------------------------------------------------------------:|\n",
    "|          Lagrange           |  {py:class}`LagrangePolynomial <.polynomials.lagrange_polynomial.LagrangePolynomial>`   |\n",
    "|           Newton            |     {py:class}`NewtonPolynomial <.polynomials.newton_polynomial.NewtonPolynomial>`      |\n",
    "|          Canonical          | {py:class}`CanonicalPolynomial <.polynomials.canonical_polynomial.CanonicalPolynomial>` |\n",
    "| Chebyshev (of the 1st kind) | {py:class}`ChebyshevPolynomial <.polynomials.chebyshev_polynomial.ChebyshevPolynomial>` |\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a29ded9e-8146-4022-a4e4-d4add1f84433",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "### Lagrange basis\n",
    "\n",
    "The Lagrange basis was the first polynomial basis you encountered in this series of tutorials. In Minterpy, the multidimensional Lagrange basis polynomial associated with the multi-index element $\\boldsymbol{\\alpha}$ is defined as a polynomial that satisfies the following condition:\n",
    "\n",
    "$$\n",
    "\\Psi_{\\mathrm{lag}, \\boldsymbol{\\alpha}} (\\boldsymbol{p}_{\\boldsymbol{\\beta}}) = \\delta_{\\boldsymbol{\\alpha}, \\boldsymbol{\\beta}}, \\;\\; \\boldsymbol{p}_{\\boldsymbol{\\beta}} \\in P_{A}, \\;\\; \\boldsymbol{\\alpha}, \\boldsymbol{\\beta} \\in A,\n",
    "$$\n",
    "\n",
    "where $P_{A}$ is the set of unisolvent nodes, $A$ is the multi-index set of exponents, and $\\delta_{\\cdot, \\cdot}$ is the Kronecker delta.\n",
    "\n",
    "```{note}\n",
    "The condition above is necessary for defining the Lagrange basis polynomials, but it does not provide the full expression of these basis polynomials as functions of $\\boldsymbol{x} \\in [-1, 1]^m$.\n",
    "Indeed in Minterpy, Lagrange basis polynomials are conceptual basis polynomials that can only be expressed in terms of another polynomial basis.\n",
    "```\n",
    "\n",
    "Polynomials in the Lagrange basis in Minterpy have limited functionality; for instance, they cannot be directly evaluated at a set of query points. Nevertheless, they serve as an entry point for function approximations using interpolating polynomials because their coefficients are highly intuitive.\n",
    "Specifically, the coefficient corresponding to the multi-index element $\\boldsymbol{\\alpha}$ of an interpolating polynomial approximating a function $f$ is\n",
    "\n",
    "$$\n",
    "c_{\\mathrm{lag}, \\boldsymbol{\\alpha}} = f(\\boldsymbol{p}_{\\boldsymbol{\\alpha}}).\n",
    "$$\n",
    "\n",
    "In other words, the coefficients are simply the values of the function at the unisolvent nodes.\n",
    "\n",
    "To do more with polynomials in the Lagrange basis, such as evaluation or manipulation, you need to transform them to another basis. This process will be covered in a later section of this tutorial."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "70b82f30-184b-43b5-81a4-d1e5c6dd005e",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "### Newton basis\n",
    "\n",
    "You've also seen the Newton basis by following these tutorials. The multidimensional Newton basis polynomial associated with multi-index element $\\alpha$ is defined as:\n",
    "\n",
    "$$\n",
    "\\Psi_{\\mathrm{nwt}, \\boldsymbol{\\alpha}} (\\boldsymbol{x}) = \\prod_{j = 1}^m \\prod_{i = 0}^{\\alpha - 1} (x_j - p_{i, j}),\n",
    "$$\n",
    "\n",
    "where $p_{i, j}$'s are the interpolation points along dimension $j$ (i.e., the so-called {ref}`generating points / nodes <fundamentals/interpolation-at-unisolvent-nodes:Generating points>` which in multiple dimensions are not the same as the unisolvent nodes).\n",
    "\n",
    "```{note}\n",
    "As you can see in the above definition, the Newton basis polynomials depend on the generating points of an interpolation grid. Such points are an integral part of the definition of the basis.\n",
    "```\n",
    "\n",
    "As an example, consider the two-dimensional multi-index set:\n",
    "\n",
    "$$\n",
    "A = \\{ (0, 0), (1, 0), (2, 0), (3, 0), (0, 1), (1, 1), (2, 1), (0, 2) \\}.\n",
    "$$\n",
    "\n",
    "Newton basis polynomial can only be defined with respect to a given generating points. Valid generating points that are distributed according to the Leja-ordered Chebyshev-Lobatto points are given in the table below.\n",
    "\n",
    "| $\\mathrm{dim} = 1$ | $\\mathrm{dim} = 2$ |\n",
    "|:-------:|:-------:|\n",
    "| $1.0$   | $-1.0$  |\n",
    "| $-1.0$  | $1.0$   |\n",
    "| $0.5$   | $-0.5$  |\n",
    "\n",
    "\n",
    "The Newton basis polynomials according to the above multi-index set of exponents are given in the table below.\n",
    "\n",
    "| $\\boldsymbol{\\alpha} \\in A$ | $\\Psi_{\\mathrm{nwt}, \\boldsymbol{\\alpha} }$ |\n",
    "|:---------:|:--------------------------------------:|\n",
    "| $(0, 0)$  | $1.0$                                  | \n",
    "| $(1, 0)$  | $x_1 - 1.0$                            |\n",
    "| $(2, 0)$  | $(x_1 - 1.0) (x_1 + 1.0)$              |\n",
    "| $(3, 0)$  | $(x_1 - 1.0) (x_1 + 1.0) (x_1 - 0.5)$  |\n",
    "| $(0, 1)$  | $x_2 + 1.0$                            |\n",
    "| $(1, 1)$  | $(x_1 - 1.0) (x_2 + 1.0)$              |\n",
    "| $(2, 1)$  | $(x_1 - 1.0) (x_1 + 1.0) (x_2 + 1.0)$  |\n",
    "| $(0, 2)$  | $(x_2 + 1.0) (x_2 - 1.0)$              |"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e81636be-5602-4ac4-ab06-20d251ead4cd",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "### Canonical basis\n",
    "\n",
    "The canonical basis is arguably the most familiar polynomial basis of them all. The multidimensional canonical basis polynomial associated with the multi-index element $\\boldsymbol{\\alpha}$ is defined as:\n",
    "\n",
    "$$\n",
    "\\Psi_{\\mathrm{can}, \\boldsymbol{\\alpha}} (\\boldsymbol{x}) = x_1^{\\alpha_1} \\cdots x_m^{\\alpha_m} = \\prod_{j = 1}^m x_j^{\\alpha_j}.\n",
    "$$\n",
    "\n",
    "```{warning}\n",
    "While polynomials in the canonical basis can be evaluated at a set of query points, high-degree polynomials in the canonical basis in Minterpy become numerically unstable to evaluate and therefore is not recommended.\n",
    "```\n",
    "\n",
    "As an example, consider the two-dimensional multi-index set:\n",
    "\n",
    "$$\n",
    "A = \\{ (0, 0) , (1, 0), (2, 0), (0, 1), (1, 1), (2, 1) \\}.\n",
    "$$\n",
    "\n",
    "The canonical basis polynomials according to the above multi-index set of exponents are given in the table below.\n",
    "\n",
    "| $\\boldsymbol{\\alpha} \\in A$ | $\\Psi_{\\mathrm{can}, \\boldsymbol{\\alpha} }$ |\n",
    "|:---------:|:------------:|\n",
    "| $(0, 0)$  | $1.0$        | \n",
    "| $(1, 0)$  | $x_1$        |\n",
    "| $(2, 0)$  | $x_1^2$      |\n",
    "| $(0, 1)$  | $x_2$        |\n",
    "| $(1, 1)$  | $x_1 x_2$    |\n",
    "| $(2, 1)$  | $x_1^2 x_2$  |"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ec939ad3-7272-47f1-ab11-69e9bf3b6032",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "### Chebyshev basis\n",
    "\n",
    "The multidimensional Chebyshev basis polynomial (of the first kind) associated with the multi-index element $\\boldsymbol{\\alpha}$ is defined as:\n",
    "\n",
    "$$\n",
    "\\Psi_{\\mathrm{cheb}, \\boldsymbol{\\alpha}} (\\boldsymbol{x}) = T_{\\alpha_1} (x_1) \\cdots T_{\\alpha_m} (x_m) = \\prod_{j = 1}^m T_{\\alpha_j} (x_j),\n",
    "$$\n",
    "\n",
    "where $T_{\\alpha_j} (x_j)$ is the $\\alpha_j$th-degree (one-dimensional) Chebyshev polynomial of the first kind associated with the $j$th-dimension.\n",
    "\n",
    "The one-dimensional Chebyshev polynomial of the first kind satisfies the following three-term recurrence (TTR) relation:\n",
    "\n",
    "$$\n",
    "\\begin{aligned}\n",
    "  T_0 (x) & = 1 \\\\\n",
    "  T_1 (x) & = x \\\\\n",
    "  T_{n + 1} (x) & = 2 \\, x \\, T_n(x)  - T_{n - 1} (x)\n",
    "\\end{aligned}\n",
    "$$\n",
    "\n",
    "As an example, consider the two-dimensional multi-index set:\n",
    "\n",
    "$$\n",
    "A = \\{ (0, 0) , (1, 0), (2, 0), (0, 1), (1, 1) \\}.\n",
    "$$\n",
    "\n",
    "The Chebyshev basis polynomial (of the first kind) according to the above multi-index set of exponents are given in the table below.\n",
    "\n",
    "| $\\boldsymbol{\\alpha} \\in A$ | $\\Psi_{\\mathrm{cheb}, \\boldsymbol{\\alpha}}$ | Full expression |\n",
    "|:---------:|:-------:|:--:|\n",
    "| $(0, 0)$  | $T_0 (x_1) T_0 (x_2)$  | $1.0$         |\n",
    "| $(1, 0)$  | $T_1 (x_1) T_0 (x_2)$  | $x_1$         |\n",
    "| $(2, 0)$  | $T_2 (x_1) T_0 (x_2)$  | $2 x_1^2 - 1$ |\n",
    "| $(0, 1)$  | $T_0 (x_1) T_1 (x_2)$  | $x_2$         |\n",
    "| $(1, 1)$  | $T_1 (x_1) T_1 (x_2)$  | $x_1 x_2$     |"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2a6bcc32-f242-4e4b-b704-72bf9ad606a8",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "## Change of basis\n",
    "\n",
    "Polynomials represented in one basis can be transformed into a polynomial in another basis with the help of various transformation classes listed in the tables below.\n",
    "\n",
    "| From Lagrange To... | Transformation |\n",
    "|:------------:|:---:|\n",
    "| Newton       | {py:class}`LagrangeToNewton <.transformations.lagrange.LagrangeToNewton>` |\n",
    "| Canonical    | {py:class}`LagrangeToCanonical <.transformations.lagrange.LagrangeToCanonical>` |\n",
    "| Chebyshev    | {py:class}`LagrangeToChebyshev <.transformations.lagrange.LagrangeToChebyshev>` |\n",
    "| **From Newton To...** |  |\n",
    "| Lagrange    | {py:class}`NewtonToLagrange <.transformations.newton.NewtonToLagrange>` |\n",
    "| Canonical   |{py:class}`NewtonToCanonical <.transformations.newton.NewtonToCanonical>` | \n",
    "| Chebyshev   | {py:class}`NewtonToChebyshev <.transformations.newton.NewtonToChebyshev>` |\n",
    "| **From canonical To...** | |\n",
    "| Lagrange | {py:class}`CanonicalToLagrange <.transformations.canonical.CanonicalToLagrange>` |\n",
    "| Newton   | {py:class}`CanonicalToNewton <.transformations.canonical.CanonicalToNewton>` |\n",
    "| Chebyshev | {py:class}`CanonicalToChebyshev <.transformations.canonical.CanonicalToChebyshev>` |\n",
    "| **From Chebyshev To...** |  |\n",
    "| Lagrange | {py:class}`ChebyshevToLagrange <.transformations.chebyshev.ChebyshevToLagrange>` |\n",
    "| Newton | {py:class}`ChebyshevToNewton <.transformations.chebyshev.ChebyshevToNewton>` |\n",
    "| Canonical | {py:class}`ChebyshevToCanonical <.transformations.chebyshev.ChebyshevToCanonical>` |\n",
    "\n",
    "For demonstrantion, see a couple of examples below."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2af9512c-2120-463e-bcbf-406791ee9cb1",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "## Example: One-dimensional polynomial\n",
    "\n",
    "Consider the following one-dimensional polynomial:\n",
    "\n",
    "$$\n",
    "Q(x) = 10 + 4.5 x - 3 x^2 + 1.5 x^3 - 1.2 x^4, x \\in [-1, 1].\n",
    "$$\n",
    "\n",
    "This polynomial is readily expressed in the canonical basis."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "90df895a-008f-4ea3-b85f-0d927f9d32b4",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "First, create the multi-index set of the polynomial:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "73f5d682-8a3e-470c-bd99-cc1612d08bd0",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "mi_1d = mp.MultiIndexSet(np.array([[0], [1], [2], [3], [4]]), lp_degree=1.0)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7ab22afa-50bc-409c-8fa7-96ea83bc2127",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "Then store the coefficients in an array:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7fadc61a-8037-4e25-a5f5-767be015a31f",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "coeffs_1d = np.array([5., 2.5, -2, -5, 1.])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b0336a89-3847-41bc-ae92-f94b823109f2",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "Finally, construct a polynomial in the canonical basis:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9d5ee9e5-bc0d-4dc1-b350-df8eb2824f9e",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "can_poly_1d = mp.CanonicalPolynomial(mi_1d, coeffs_1d)\n",
    "can_poly_1d"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cf59adf1-fbe9-4574-bc15-682a15366e52",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "The plot of the polynomial is shown below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "39b4892c-15ee-42e4-b818-49a79f241aab",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "xx_test = np.linspace(-1, 1, 1000)\n",
    "plt.plot(xx_test, can_poly_1d(xx_test))\n",
    "plt.xlabel(\"$x$\", fontsize=14)\n",
    "plt.ylabel(\"$y$\", fontsize=14)\n",
    "plt.tick_params(axis='both', which='major', labelsize=12);"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bc151fb3-0e59-4a4a-b2c1-9d6c71fd1955",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "The same polynomial can be expressed in a different basis using the help of a transformation class.\n",
    "Note that all instance of the transformation class must be called to carry out the actual transformation that returns a polynomial in the new basis."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "82a188fe-0b3c-47f4-8595-1b86447a90f8",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "The one-dimensional canonical basis polynomial are shown in the plots below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6d31813e-1eb9-4aa1-b3fd-1ae1e1ca82ac",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "can_monomials_1d = np.prod(\n",
    "        np.power(\n",
    "            xx_test[:, np.newaxis][:, None, :],\n",
    "            can_poly_1d.multi_index.exponents[None, :, :],\n",
    "        ),\n",
    "        axis=-1,\n",
    "    )\n",
    "fig, axs = plt.subplots(nrows=2, ncols=3, figsize=(12, 8))\n",
    "\n",
    "axs[0, 0].plot(xx_test, can_monomials_1d[:, 0])\n",
    "axs[0, 0].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[0, 0].set_ylabel(\"$y$\", fontsize=14);\n",
    "axs[0, 0].set_title(\"$\\\\Psi_{\\\\mathrm{can}, (0)}$\", fontsize=14)\n",
    "axs[0, 0].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "axs[0, 1].plot(xx_test, can_monomials_1d[:, 1])\n",
    "axs[0, 1].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[0, 1].set_title(\"$\\\\Psi_{\\\\mathrm{can}, (1)}$\", fontsize=14)\n",
    "axs[0, 1].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "axs[0, 2].plot(xx_test, can_monomials_1d[:, 2])\n",
    "axs[0, 2].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[0, 2].set_title(\"$\\\\Psi_{\\\\mathrm{can}, (2)}$\", fontsize=14)\n",
    "axs[0, 2].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "axs[1, 0].plot(xx_test, can_monomials_1d[:, 3])\n",
    "axs[1, 0].set_xlabel(\"$y$\", fontsize=14);\n",
    "axs[1, 0].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[1, 0].set_title(\"$\\\\Psi_{\\\\mathrm{can}, (3)}$\", fontsize=14)\n",
    "axs[1, 0].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "axs[1, 1].plot(xx_test, can_monomials_1d[:, 4])\n",
    "axs[1, 1].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[1, 1].set_title(\"$\\\\Psi_{\\\\mathrm{can}, (4)}$\", fontsize=14)\n",
    "axs[1, 1].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "\n",
    "axs[1, 2].get_xaxis().set_visible(False)\n",
    "axs[1, 2].get_yaxis().set_visible(False)\n",
    "axs[1, 2].spines['top'].set_visible(False)\n",
    "axs[1, 2].spines['bottom'].set_visible(False)\n",
    "axs[1, 2].spines['right'].set_visible(False)\n",
    "axs[1, 2].spines['left'].set_visible(False)\n",
    "\n",
    "fig.tight_layout()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "83da283f-63ea-4657-bfe0-6daff24a927d",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "### In the (1D) Lagrange basis\n",
    "\n",
    "The transformation of a polynomial in the canonical basis to the one in the Lagrange basis is carried out by an instance of {py:class}`CanonicalToLagrange <.transformations.canonical.CanonicalToLagrange>`:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b6eeb5ef-e492-4778-b905-94c46463683f",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "lag_poly_1d = mp.CanonicalToLagrange(can_poly_1d)()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f7453591-b071-4e07-9b49-6d4c436369ce",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "The coefficients of the Lagrange polynomial are:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c5df1308-3b46-45a6-95ad-9d7688832c02",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "lag_poly_1d.coeffs"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6d280c5a-eaa6-40cb-9756-3217574effa6",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "These coefficients are the function values at the unisolvent nodes:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f24ff5dd-f528-44ef-9df8-b4f414dc38ef",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "can_poly_1d(can_poly_1d.grid.unisolvent_nodes)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3277289a-6667-46a5-bc9a-88825de135a2",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "```{note}\n",
    "Although the canonical polynomial can be defined without the need for an interpolation grid, the transformation to a Lagrange basis requires such a grid. If not specified during construction, Minterpy automatically creates an interpolating grid based on the Leja-ordered Chebyshev-Lobatto points.\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "69fff6a5-3530-4805-be7d-3aaf6aa2b13b",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "The one-dimensional Lagrange basis polynomials are shown in the plots below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7847abe1-d03a-4716-838d-407042b37976",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "lag_monomials_newt_basis = mp.NewtonPolynomial(\n",
    "    lag_poly_1d.multi_index,\n",
    "    mp.LagrangeToNewton(lag_poly_1d).transformation_operator.array_repr_full,\n",
    "    grid=lag_poly_1d.grid,\n",
    ")\n",
    "lag_monomials_1d = lag_monomials_newt_basis(xx_test)\n",
    "\n",
    "fig, axs = plt.subplots(nrows=2, ncols=3, figsize=(12, 8))\n",
    "\n",
    "axs[0, 0].plot(xx_test, lag_monomials_1d[:, 0])\n",
    "axs[0, 0].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[0, 0].set_ylabel(\"$y$\", fontsize=14);\n",
    "axs[0, 0].set_title(\"$\\\\Psi_{\\\\mathrm{lag}, (0)}$\", fontsize=14)\n",
    "axs[0, 0].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "axs[0, 1].plot(xx_test, lag_monomials_1d[:, 1])\n",
    "axs[0, 1].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[0, 1].set_title(\"$\\\\Psi_{\\\\mathrm{lag}, (1)}$\", fontsize=14)\n",
    "axs[0, 1].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "axs[0, 2].plot(xx_test, lag_monomials_1d[:, 2])\n",
    "axs[0, 2].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[0, 2].set_title(\"$\\\\Psi_{\\\\mathrm{lag}, (2)}$\", fontsize=14)\n",
    "axs[0, 2].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "axs[1, 0].plot(xx_test, lag_monomials_1d[:, 3])\n",
    "axs[1, 0].set_xlabel(\"$y$\", fontsize=14);\n",
    "axs[1, 0].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[1, 0].set_title(\"$\\\\Psi_{\\\\mathrm{lag}, (3)}$\", fontsize=14)\n",
    "axs[1, 0].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "axs[1, 1].plot(xx_test, lag_monomials_1d[:, 4])\n",
    "axs[1, 1].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[1, 1].set_title(\"$\\\\Psi_{\\\\mathrm{lag}, (4)}$\", fontsize=14)\n",
    "axs[1, 1].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "axs[1, 2].get_xaxis().set_visible(False)\n",
    "axs[1, 2].get_yaxis().set_visible(False)\n",
    "axs[1, 2].spines['top'].set_visible(False)\n",
    "axs[1, 2].spines['bottom'].set_visible(False)\n",
    "axs[1, 2].spines['right'].set_visible(False)\n",
    "axs[1, 2].spines['left'].set_visible(False)\n",
    "\n",
    "fig.tight_layout()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "291729a6-4b17-447e-a0f3-8a2369965e87",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "### In the (1D) Newton basis\n",
    "\n",
    "The transformation of a polynomial in the canonical basis to the one in the Newton basis is carried out by an instance of {py:class}`CanonicalToNewton <.transformations.canonical.CanonicalToNewton>`:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4d10fee5-650b-439e-aef6-7902bb9b254d",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "nwt_poly_1d = mp.CanonicalToNewton(can_poly_1d)()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2567eccc-349b-4b47-aab8-133fa987304d",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "The coefficients of the Newton polynomial are:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bc31cf56-a6df-4c40-be26-f620a2335691",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "nwt_poly_1d.coeffs"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d054af21-9046-48b5-bce7-b06b09de44bf",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "Although the canonical polynomial can be defined without the need for an interpolation grid, the transformation to a Newton basis requires such a grid. If not specified during construction, Minterpy automatically creates an interpolating grid based on the Leja-ordered Chebyshev-Lobatto points.\n",
    "This means the generating points of the grid are:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "25d2da58-e595-47fd-8af9-77b8652066fe",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "nwt_poly_1d.grid.generating_points"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6868b729-81a5-4c8e-8994-f1a20d4d0381",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "With these coefficients and generating points, the same polynomial can be expressed in the Newton basis as follows:\n",
    "\n",
    "$$\n",
    "Q(x) = 1.5 - 2.5 (x - 1) - 1 (x - 1) (x + 1) - 4.29289322 (x - 1) (x + 1) x + (x - 1) (x + 1) x (x - 0.707106781).\n",
    "$$"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "48ee49a6-8852-465c-a633-d95a456a43cf",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "The one-dimensional Newton basis polynomials are shown in the plots below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3d56701c-77b3-477d-90f5-862d52d775f0",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "nwt_monomials_1d = mp.utils.polynomials.newton.eval_newton_monomials(\n",
    "    xx_test[:, np.newaxis],\n",
    "    nwt_poly_1d.multi_index.exponents,\n",
    "    nwt_poly_1d.grid.generating_points,\n",
    ")\n",
    "fig, axs = plt.subplots(nrows=2, ncols=3, figsize=(12, 8))\n",
    "\n",
    "axs[0, 0].plot(xx_test, nwt_monomials_1d[:, 0])\n",
    "axs[0, 0].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[0, 0].set_ylabel(\"$y$\", fontsize=14);\n",
    "axs[0, 0].set_title(\"$\\\\Psi_{\\\\mathrm{nwt}, (0)}$\", fontsize=14)\n",
    "axs[0, 0].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "axs[0, 1].plot(xx_test, nwt_monomials_1d[:, 1])\n",
    "axs[0, 1].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[0, 1].set_title(\"$\\\\Psi_{\\\\mathrm{nwt}, (1)}$\", fontsize=14)\n",
    "axs[0, 1].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "axs[0, 2].plot(xx_test, nwt_monomials_1d[:, 2])\n",
    "axs[0, 2].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[0, 2].set_title(\"$\\\\Psi_{\\\\mathrm{nwt}, (2)}$\", fontsize=14)\n",
    "axs[0, 2].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "axs[1, 0].plot(xx_test, nwt_monomials_1d[:, 3])\n",
    "axs[1, 0].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[1, 0].set_ylabel(\"$y$\", fontsize=14);\n",
    "axs[1, 0].set_title(\"$\\\\Psi_{\\\\mathrm{nwt}, (3)}$\", fontsize=14)\n",
    "axs[1, 0].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "axs[1, 1].plot(xx_test, nwt_monomials_1d[:, 4])\n",
    "axs[1, 1].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[1, 1].set_title(\"$\\\\Psi_{\\\\mathrm{nwt}, (4)}$\", fontsize=14)\n",
    "axs[1, 1].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "\n",
    "axs[1, 2].get_xaxis().set_visible(False)\n",
    "axs[1, 2].get_yaxis().set_visible(False)\n",
    "axs[1, 2].spines['top'].set_visible(False)\n",
    "axs[1, 2].spines['bottom'].set_visible(False)\n",
    "axs[1, 2].spines['right'].set_visible(False)\n",
    "axs[1, 2].spines['left'].set_visible(False)\n",
    "\n",
    "fig.tight_layout()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "aefc7655-1f8c-408b-b48b-780bc3f757cb",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "### In the (1D) Chebyshev basis\n",
    "\n",
    "The transformation of a polynomial in the canonical basis to the one in the Chebyshev basis is carried out by an instance of {py:class}`CanonicalToChebyshev <.transformations.canonical.CanonicalToChebyshev>`:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0d647fe1-a3ab-4e62-a54f-411312248448",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "cheb_poly_1d = mp.CanonicalToChebyshev(can_poly_1d)()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "40c25222-a581-4e5b-ac36-01e61389c235",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "The coefficients of the Chebyshev polynomial are:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6529df19-2e19-49c3-a73c-bd14fb9102d8",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "cheb_poly_1d.coeffs"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bea45ca1-6765-44e5-87e4-df1173979227",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "With these coefficients and generating points, the same polynomial can be expressed in the Chebyshev basis as follows:\n",
    "\n",
    "$$\n",
    "Q(x) = 4.375 - 1.25 T_1 (x) - 0.5 T_2 (x) - 1.25 T_3 (x) + 0.125 T_4(x).\n",
    "$$"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "feefe124-f45c-48aa-a2d3-01620c596957",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "The one-dimensional Chebyshev basis polynomials are shown in the plots below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2743aeea-c69c-4c3e-8128-7edc703c4d0e",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "cheb_monomials_1d = mp.utils.polynomials.chebyshev.evaluate_monomials(\n",
    "    xx_test[:, np.newaxis],\n",
    "    cheb_poly_1d.multi_index.exponents,\n",
    ")\n",
    "fig, axs = plt.subplots(nrows=2, ncols=3, figsize=(12, 8))\n",
    "\n",
    "axs[0, 0].plot(xx_test, cheb_monomials_1d[:, 0])\n",
    "axs[0, 0].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[0, 0].set_ylabel(\"$y$\", fontsize=14);\n",
    "axs[0, 0].set_title(\"$\\\\Psi_{\\\\mathrm{cheb}, (0)}$\", fontsize=14)\n",
    "axs[0, 0].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "axs[0, 1].plot(xx_test, cheb_monomials_1d[:, 1])\n",
    "axs[0, 1].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[0, 1].set_title(\"$\\\\Psi_{\\\\mathrm{cheb}, (1)}$\", fontsize=14)\n",
    "axs[0, 1].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "axs[0, 2].plot(xx_test, cheb_monomials_1d[:, 2])\n",
    "axs[0, 2].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[0, 2].set_title(\"$\\\\Psi_{\\\\mathrm{cheb}, (2)}$\", fontsize=14)\n",
    "axs[0, 2].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "axs[1, 0].plot(xx_test, cheb_monomials_1d[:, 3])\n",
    "axs[1, 0].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[1, 0].set_ylabel(\"$y$\", fontsize=14);\n",
    "axs[1, 0].set_title(\"$\\\\Psi_{\\\\mathrm{cheb}, (3)}$\", fontsize=14)\n",
    "axs[1, 0].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "axs[1, 1].plot(xx_test, cheb_monomials_1d[:, 4])\n",
    "axs[1, 1].set_xlabel(\"$x$\", fontsize=14);\n",
    "axs[1, 1].set_title(\"$\\\\Psi_{\\\\mathrm{cheb}, (4)}$\", fontsize=14)\n",
    "axs[1, 1].tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "\n",
    "axs[1, 2].get_xaxis().set_visible(False)\n",
    "axs[1, 2].get_yaxis().set_visible(False)\n",
    "axs[1, 2].spines['top'].set_visible(False)\n",
    "axs[1, 2].spines['bottom'].set_visible(False)\n",
    "axs[1, 2].spines['right'].set_visible(False)\n",
    "axs[1, 2].spines['left'].set_visible(False)\n",
    "\n",
    "fig.tight_layout()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f7dcb220-739a-48fe-aabe-ac5ce448855c",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "## Example: Two-dimensional polynomial\n",
    "\n",
    "Consider now the two-dimensional function:\n",
    "\n",
    "$$\n",
    "f(x_1, x_2) = \\left( 25 - (x_1 - 0.5)^2 - (x_2 - 0.5)^2 \\right)^{0.5}, x_1, x_2 \\in [-1, 1].\n",
    "$$"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e7d00b31-1844-46e6-b9e4-ca6d87bc8dec",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "The function is defined in Python as follows:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c42f2f14-d90d-4195-a37f-76ce67a62f1f",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def fun(xx):\n",
    "    return np.sqrt(25 - (xx[:, 0] - 0.5)**2 - (xx[:, 1] - 0.5)**2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "15e5f04d-9ee9-4bbc-8265-a42940840838",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "from mpl_toolkits.axes_grid1 import make_axes_locatable\n",
    "\n",
    "# --- Create 2D data\n",
    "xx_1d = np.linspace(-1.0, 1.0, 1000)[:, np.newaxis]\n",
    "mesh_2d = np.meshgrid(xx_1d, xx_1d)\n",
    "xx_2d = np.array(mesh_2d).T.reshape(-1, 2)\n",
    "yy_2d = fun(xx_2d)\n",
    "\n",
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    yy_2d.reshape(1000,1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"Surface plot\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Contour\n",
    "axs_2 = plt.subplot(122)\n",
    "cf = axs_2.contourf(\n",
    "    mesh_2d[0], mesh_2d[1], yy_2d.reshape(1000, 1000).T, cmap=\"plasma\"\n",
    ")\n",
    "axs_2.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_2.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_2.set_title(\"Contour plot\", fontsize=14)\n",
    "divider = make_axes_locatable(axs_2)\n",
    "cax = divider.append_axes('right', size='5%', pad=0.05)\n",
    "fig.colorbar(cf, cax=cax, orientation='vertical')\n",
    "axs_2.axis('scaled')\n",
    "axs_2.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "fig.tight_layout(pad=6.0)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2c5f407f-4fbf-4b60-9716-fe3a45973e24",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "Because the function is not a polynomial (a square root is involved), creating a polynomial that approximates the function is much more intuitive in the Lagrange basis. In the other basis, it is not straightforward to intuit what the coefficient values should be."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "732fc770-b186-4973-8c9c-385290b9f32a",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "First, create a two-dimensional multi-index of specified degree:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b0ef93d9-1639-4beb-b9b6-c732e60faca7",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "mi_2d = mp.MultiIndexSet.from_degree(2, 3, 1.0)\n",
    "mi_2d"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4488bb4b-c324-46a8-b881-9f973ef7d61e",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "Then, create an interpolation grid and evaluate the function at the unisolvent nodes:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e12ebc38-ace2-4d6a-8cbc-b7f6038face4",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Interpolation grid\n",
    "grd_2d = mp.Grid(mi_2d)\n",
    "# Coefficients of the Lagrange polynomial\n",
    "coeffs_2d = grd_2d(fun)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3ac6712c-c497-48cf-88e7-8e6311b409cc",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "Finally, construct a polynomial in the Lagrange basis given the grid and coefficients:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "25a71a7c-fe7b-403d-af41-4c521c510785",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "lag_poly_2d = mp.LagrangePolynomial.from_grid(grd_2d, coeffs_2d)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6078fb75-3a4f-4997-8489-5ffeaca234b2",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "The two-dimensional Lagrange basis polynomials are shown in the plots below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "45a33bf2-dff1-49b7-9f1a-a1c73a8c4046",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create 2D data\n",
    "xx_1d = np.linspace(-1.0, 1.0, 1000)[:, np.newaxis]\n",
    "mesh_2d = np.meshgrid(xx_1d, xx_1d)\n",
    "xx_2d = np.array(mesh_2d).T.reshape(-1, 2)\n",
    "lag_monomials_newt_basis_2d = mp.NewtonPolynomial(\n",
    "    lag_poly_2d.multi_index,\n",
    "    mp.LagrangeToNewton(lag_poly_2d).transformation_operator.array_repr_full,\n",
    "    grid=lag_poly_2d.grid,\n",
    ")\n",
    "lag_monomials_2d = lag_monomials_newt_basis_2d(xx_2d)\n",
    "\n",
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    lag_monomials_2d[:, 0].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{lag}, (0, 0)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    lag_monomials_2d[:, 1].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{lag}, (1, 0)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4f06c399-67a9-42cd-afbb-d331fc270998",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    lag_monomials_2d[:, 2].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{lag}, (2, 0)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    lag_monomials_2d[:, 3].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{lag}, (3, 0)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "de2e6e5f-6b3e-4d00-a239-5ac05d0fd400",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    lag_monomials_2d[:, 4].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{lag}, (0, 1)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    lag_monomials_2d[:, 5].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{lag}, (1, 1)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "68e7c9eb-7d5c-4881-878a-fcdfd7484bab",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    lag_monomials_2d[:, 6].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{lag}, (2, 1)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    lag_monomials_2d[:, 7].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{lag}, (0, 2)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "49e64584-5012-4a60-8942-c92ef9f84530",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    lag_monomials_2d[:, 8].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{lag}, (1, 2)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    lag_monomials_2d[:, 9].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{lag}, (0, 3)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "367c1922-6008-421c-b4c3-f5a189daf35f",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "### In the (2D) Newton basis\n",
    "\n",
    "You can transform a Minterpy polynomial in the Lagrange basis to another polynomial in the Newton with the help of {py:class}`LagrangeToNewton <.transformations.lagrange.LagrangeToNewton>`:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "af1e9b4d-d5d1-4fa6-bf34-e2826abdd40f",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "nwt_poly_2d = mp.LagrangeToNewton(lag_poly_2d)()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4f334651-5b4a-4479-b457-51808fd22208",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "The coefficients of the Newton polynomial are:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c7a0885c-28d8-4616-8764-972c8439c566",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "nwt_poly_2d.coeffs"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "415ea5d6-a5dc-426a-92f0-e77731c5e267",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "The two-dimensional Newton basis polynomials are shown in the plots below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "602a4560-67ba-44ff-ab5d-167e745e8638",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create 2D data\n",
    "xx_1d = np.linspace(-1.0, 1.0, 1000)[:, np.newaxis]\n",
    "mesh_2d = np.meshgrid(xx_1d, xx_1d)\n",
    "xx_2d = np.array(mesh_2d).T.reshape(-1, 2)\n",
    "nwt_monomials_2d = mp.utils.polynomials.newton.eval_newton_monomials(\n",
    "    xx_2d,\n",
    "    mi_2d.exponents,\n",
    "    grd_2d.generating_points,\n",
    ")\n",
    "\n",
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    nwt_monomials_2d[:, 0].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{nwt}, (0, 0)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    nwt_monomials_2d[:, 1].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{nwt}, (1, 0)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "38140830-025b-480e-aa4f-f21a5492aaed",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    nwt_monomials_2d[:, 2].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{nwt}, (2, 0)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    nwt_monomials_2d[:, 3].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{nwt}, (3, 0)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "44d2aa8b-8270-4d42-9597-c1cc23267f19",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    nwt_monomials_2d[:, 4].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{nwt}, (0, 1)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    nwt_monomials_2d[:, 5].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{nwt}, (1, 1)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f99496f7-fd22-4699-970a-16001d59c285",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    nwt_monomials_2d[:, 6].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{nwt}, (2, 1)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    nwt_monomials_2d[:, 7].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{nwt}, (0, 2)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7b329731-836a-4320-b498-8ba835243af7",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    nwt_monomials_2d[:, 8].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{nwt}, (1, 2)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    nwt_monomials_2d[:, 9].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{nwt}, (0, 3)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "609c0ce1-8535-4a56-ba3a-b6a55df56b69",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "### In the (2D) canonical basis\n",
    "\n",
    "You can transform a Minterpy polynomial in the Lagrange basis to another polynomial in the canonical basis with the help of {py:class}`LagrangeToCanonical <.transformations.lagrange.LagrangeToCanonical>`:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "04a6ec55-b66b-4a36-93a6-e4778a51f4d0",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "can_poly_2d = mp.LagrangeToCanonical(lag_poly_2d)()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9d19ad7b-a803-4337-9b19-f3648963588c",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "The coefficients of the canonical polynomial are:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7567ac2c-1949-4198-8528-6e7edabdde64",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "can_poly_2d.coeffs"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "10a4f0a4-c70a-4859-b4bc-fc0b1393d0a4",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "The two-dimensional canonical basis polynomials are shown in the plots below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5327a096-d24b-4eca-b5fc-5652ffbbf554",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create 2D data\n",
    "xx_1d = np.linspace(-1.0, 1.0, 1000)[:, np.newaxis]\n",
    "mesh_2d = np.meshgrid(xx_1d, xx_1d)\n",
    "xx_2d = np.array(mesh_2d).T.reshape(-1, 2)\n",
    "can_monomials_2d = np.prod(\n",
    "        np.power(\n",
    "            xx_2d[:, None, :],\n",
    "            can_poly_2d.multi_index.exponents[None, :, :],\n",
    "        ),\n",
    "        axis=-1,\n",
    "    )\n",
    "\n",
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    can_monomials_2d[:, 0].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{can}, (0, 0)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    can_monomials_2d[:, 1].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{can}, (1, 0)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9ac70acc-e179-4dd5-ac33-04956eb942f9",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    can_monomials_2d[:, 2].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{can}, (2, 0)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    can_monomials_2d[:, 3].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{can}, (3, 0)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1dbcde7a-577f-4922-a403-a44d429172ca",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    can_monomials_2d[:, 4].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{can}, (0, 1)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    can_monomials_2d[:, 5].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{can}, (1, 1)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b5c9dd9e-4acb-4276-a80c-ac5a954e2e61",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    can_monomials_2d[:, 6].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{can}, (2, 1)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    can_monomials_2d[:, 7].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{can}, (0, 2)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2fa2e571-f82d-444b-b9f7-ca38b0e0efc0",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    can_monomials_2d[:, 8].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{can}, (1, 2)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    can_monomials_2d[:, 9].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{can}, (0, 3)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "97329898-d365-4628-babb-2a47f9cecd33",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "### In the (2D) Chebyshev basis\n",
    "\n",
    "Finally, you can transform a Minterpy polynomial in the Lagrange basis to another polynomial in the Chebyshev basis (of the first kind) with the help of {py:class}`LagrangeToChebyshev <.transformations.lagrange.LagrangeToChebyshev>`:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "43346e2c-1250-4d24-b0fa-86e67bf6eca2",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "cheb_poly_2d = mp.LagrangeToChebyshev(lag_poly_2d)()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c6a15e21-d849-4724-8c09-f038a56bd902",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "The coefficients of the canonical polynomial are:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bf9b72a4-28af-4edf-8ce8-6bf096d0d855",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "cheb_poly_2d.coeffs"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5306cb68-d8b2-4af2-8d0a-f3b1a2549264",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "The two-dimensional Chebyshev basis polynomials (of the first kind) are shown in the plots below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fa16f9d1-daef-4bb8-bc9e-51bda2fdc2ca",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create 2D data\n",
    "xx_1d = np.linspace(-1.0, 1.0, 1000)[:, np.newaxis]\n",
    "mesh_2d = np.meshgrid(xx_1d, xx_1d)\n",
    "xx_2d = np.array(mesh_2d).T.reshape(-1, 2)\n",
    "cheb_monomials_2d = mp.utils.polynomials.chebyshev.evaluate_monomials(\n",
    "    xx_2d,\n",
    "    cheb_poly_2d.multi_index.exponents,\n",
    ")\n",
    "\n",
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    cheb_monomials_2d[:, 0].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{cheb}, (0, 0)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    cheb_monomials_2d[:, 1].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{cheb}, (1, 0)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "46747020-25f2-4023-96f8-1581cdfebb70",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    cheb_monomials_2d[:, 2].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{cheb}, (2, 0)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    cheb_monomials_2d[:, 3].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{cheb}, (3, 0)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "84ba523c-4936-475d-b5ea-1123ead08982",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    cheb_monomials_2d[:, 4].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{cheb}, (0, 1)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    cheb_monomials_2d[:, 5].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{cheb}, (1, 1)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d2f9da61-e7a5-4622-965f-afdb2869120a",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    cheb_monomials_2d[:, 6].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{cheb}, (2, 1)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    cheb_monomials_2d[:, 7].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{cheb}, (0, 2)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "df761627-ee14-4e3f-87f9-43d58c7b4b4d",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# --- Create two-dimensional plots\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(121, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    cheb_monomials_2d[:, 8].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{cheb}, (1, 2)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)\n",
    "\n",
    "# Surface\n",
    "axs_1 = plt.subplot(122, projection='3d')\n",
    "axs_1.plot_surface(\n",
    "    mesh_2d[0],\n",
    "    mesh_2d[1],\n",
    "    cheb_monomials_2d[:, 9].reshape(1000, 1000).T,\n",
    "    linewidth=0,\n",
    "    cmap=\"plasma\",\n",
    "    antialiased=False,\n",
    "    alpha=0.5\n",
    ")\n",
    "axs_1.set_xlabel(\"$x_1$\", fontsize=14)\n",
    "axs_1.set_ylabel(\"$x_2$\", fontsize=14)\n",
    "axs_1.set_title(\"$\\\\Psi_{\\\\mathrm{cheb}, (0, 3)}$\", fontsize=14)\n",
    "axs_1.tick_params(axis='both', which='major', labelsize=12)"
   ]
  },
  {
   "metadata": {},
   "cell_type": "markdown",
   "source": [
    "## From interpolant to interpolating polynomial\n",
    "\n",
    "The {doc}`Quickstart Guide </getting-started/functions-approximation>` introduced\n",
    "you with the {py:func}`interpolate() <.interpolation.interpolate>` function to\n",
    "conveniently create an interpolant out of a function for a given spatial\n",
    "dimension, polynomial degree, and $l_p$-degree.\n",
    "As noted in the previous tutorials, while {py:func}`interpolate() <.interpolation.interpolate>`\n",
    "does not produce an instance of Minterpy polynomials\n",
    "(and instead, an instance of {py:class}`Interpolant <.interpolation.Interpolant>`)\n",
    "you can conveniently retrieve the polynomial by the methods summarized in the\n",
    "table below.\n",
    "\n",
    "|                               Method                                |                    Return the interpolant as a polynomial in the...                     |\n",
    "|:-------------------------------------------------------------------:|:---------------------------------------------------------------------------------------:|\n",
    "|    {py:meth}`to_newton() <.interpolation.Interpolant.to_newton>`    |     {py:class}`NewtonPolynomial <.polynomials.newton_polynomial.NewtonPolynomial>`      |\n",
    "|  {py:meth}`to_lagrange() <.interpolation.Interpolant.to_lagrange>`  |  {py:class}`LagrangePolynomial <.polynomials.lagrange_polynomial.LagrangePolynomial>`   |\n",
    "| {py:meth}`to_canonical() <.interpolation.Interpolant.to_canonical>` | {py:class}`CanonicalPolynomial <.polynomials.canonical_polynomial.CanonicalPolynomial>` |\n",
    "| {py:meth}`to_chebyshev() <.interpolation.Interpolant.to_chebyshev>` | {py:class}`CanonicalPolynomial <.polynomials.chebyshev_polynomial.ChebyshevPolynomial>` |"
   ],
   "id": "3d20a42e4ebc930b"
  },
  {
   "cell_type": "markdown",
   "id": "945d9e26-af69-42b9-8694-0fb1fe63dd88",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": []
   },
   "source": [
    "## Summary\n",
    "\n",
    "In this tutorial, you've explored the different polynomial bases supported by Minterpy. Depending on the problem at hand, it may be more intuitive to construct a polynomial in a specific basis.\n",
    "\n",
    "Once a polynomial has been constructed in one basis, it can be transformed into another. The result of this transformation is a polynomial that is equivalent to the original but represented in a different basis.\n",
    "\n",
    "Note, however, that Minterpy has different supported features for each polynomial basis as summarized by the following table.\n",
    "\n",
    "| Operations                        | Lagrange | Newton   | Canonical | Chebyshev |\n",
    "|:----------------------------------|:--------:|:--------:|:---------:|:---------:|\n",
    "| Transformation from-and-to        | &#10003; | &#10003; | &#10003;  | &#10003;  |\n",
    "| Evaluation                        | &#10005; | &#10003; | &#10003;  | &#10003;  |\n",
    "| Addition/Subtraction (Scalar)     | &#10003; | &#10003; | &#10003;  | &#10003;  |\n",
    "| Addition/Subtraction (Polynomial) | &#10005; | &#10003; | &#10003;  | &#10003;  |\n",
    "| Multiplication (Scalar)           | &#10003; | &#10003; | &#10003;  | &#10003;  |\n",
    "| Multiplication (Polynomial)       | &#10005; | &#10003; | &#10003;  | &#10003;  |\n",
    "| Division (Scalar)                 | &#10003; | &#10003; | &#10003;  | &#10003;  |\n",
    "| Division (Polynomial)             | &#10005; | &#10005; | &#10005;  | &#10005;  |\n",
    "| Differentiation                   | &#10005; | &#10003; | &#10003;  | &#10005;  |\n",
    "| Definite integration              | &#10005; | &#10003; | &#10003;  | &#10005;  |\n",
    "\n",
    "---\n",
    "\n",
    "So far, you've learned:\n",
    "\n",
    "- how to construct Minterpy polynomials in one or more dimensions\n",
    "- what operations you can perform with Minterpy polynomials (arithmetic and calculus operations)\n",
    "- the different polynomial bases and how to transform between them\n",
    "\n",
    "In all these tutorials, you typically start with a given function of interest, where you can evaluate it at chosen locations (i.e., the unisolvent nodes) to construct an interpolating polynomial.\n",
    "\n",
    "One important problem remains: _How do you construct a polynomial from a given set of scattered data?_"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.16"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
