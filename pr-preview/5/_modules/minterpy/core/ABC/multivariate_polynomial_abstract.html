
<!DOCTYPE html>


<html lang="en" data-content_root="../../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>minterpy.core.ABC.multivariate_polynomial_abstract &#8212; Minterpy 0.1</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles.css?v=a88e7498" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/minterpy/core/ABC/multivariate_polynomial_abstract';</script>
    <link rel="canonical" href="https://minterpy.readthedocs.io/en/latest/_modules/minterpy/core/ABC/multivariate_polynomial_abstract.html" />
    <link rel="icon" href="../../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="0.1.dev1+g36411df" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../../_static/Wordmark-color.png" class="logo__image only-light" alt="Minterpy 0.1 - Home"/>
    <img src="../../../../_static/Wordmark-color.png" class="logo__image only-dark pst-js-only" alt="Minterpy 0.1 - Home"/>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../getting-started/index.html">
    Getting Started
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../how-to/index.html">
    How-to
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../fundamentals/index.html">
    Fundamentals
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../api/index.html">
    API Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../contributors/index.html">
    Contributors
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/minterpy-project/minterpy" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://minterpy-project.github.io/minterpy/latest/" title="Latest Docs" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-dev fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Latest Docs</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://minterpy-project.github.io/minterpy/stable/" title="Stable Docs" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-solid fa-box-open fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Stable Docs</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../getting-started/index.html">
    Getting Started
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../how-to/index.html">
    How-to
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../fundamentals/index.html">
    Fundamentals
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../api/index.html">
    API Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../contributors/index.html">
    Contributors
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/minterpy-project/minterpy" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://minterpy-project.github.io/minterpy/latest/" title="Latest Docs" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-dev fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Latest Docs</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://minterpy-project.github.io/minterpy/stable/" title="Stable Docs" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-solid fa-box-open fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Stable Docs</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">minterpy.core.ABC.multivariate_polynomial_abstract</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for minterpy.core.ABC.multivariate_polynomial_abstract</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains the abstract base classes for all polynomial base classes.</span>

<span class="sd">All concrete implementations of polynomial bases must inherit from</span>
<span class="sd">the abstract base class. This ensures a consistent interface across</span>
<span class="sd">all polynomials. As a result, additional features can be developed without</span>
<span class="sd">needing to reference specific polynomial classes,</span>
<span class="sd">while allowing each concrete class to manage its own implementation details.</span>

<span class="sd">See e.g. :PEP:`3119` for further explanations on the topic.</span>

<span class="sd">----</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">from</span> <span class="nn">minterpy.global_settings</span> <span class="kn">import</span> <span class="n">ARRAY</span><span class="p">,</span> <span class="n">SCALAR</span>
<span class="kn">from</span> <span class="nn">minterpy.core.grid</span> <span class="kn">import</span> <span class="n">Grid</span>
<span class="kn">from</span> <span class="nn">minterpy.core.multi_index</span> <span class="kn">import</span> <span class="n">MultiIndexSet</span>
<span class="kn">from</span> <span class="nn">minterpy.utils.verification</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">check_type</span><span class="p">,</span>
    <span class="n">check_values</span><span class="p">,</span>
    <span class="n">is_real_scalar</span><span class="p">,</span>
    <span class="n">check_shape</span><span class="p">,</span>
    <span class="n">shape_eval_output</span><span class="p">,</span>
    <span class="n">verify_domain</span><span class="p">,</span>
    <span class="n">verify_poly_coeffs</span><span class="p">,</span>
    <span class="n">verify_poly_domain</span><span class="p">,</span>
    <span class="n">verify_poly_power</span><span class="p">,</span>
    <span class="n">verify_query_points</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">minterpy.utils.multi_index</span> <span class="kn">import</span> <span class="n">find_match_between</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;MultivariatePolynomialABC&quot;</span><span class="p">,</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="MultivariatePolynomialABC">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialABC">[docs]</a>
<span class="k">class</span> <span class="nc">MultivariatePolynomialABC</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;the most general abstract base class for multivariate polynomials.</span>

<span class="sd">    Every data type which needs to behave like abstract polynomial(s) should subclass this class and implement all the abstract methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ARRAY</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Abstract container which stores the coefficients of the polynomial.</span>

<span class="sd">        This is a placeholder of the ABC, which is overwritten by the concrete implementation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@coeffs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">num_active_monomials</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Abstract container for the number of monomials of the polynomial(s).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a placeholder of the ABC, which is overwritten</span>
<span class="sd">        by the concrete implementation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">spatial_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Abstract container for the dimension of space where the polynomial(s) live on.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a placeholder of the ABC, which is overwritten by the concrete implementation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">unisolvent_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Abstract container for unisolvent nodes the polynomial(s) is(are) defined on.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a placeholder of the ABC, which is overwritten by the concrete implementation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="MultivariatePolynomialABC._eval">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialABC._eval">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_eval</span><span class="p">(</span>
        <span class="n">poly</span><span class="p">:</span> <span class="s2">&quot;MultivariatePolynomialABC&quot;</span><span class="p">,</span>
        <span class="n">xx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Abstract method to the polynomial evaluation function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        poly : MultivariatePolynomialABC</span>
<span class="sd">            A concrete instance of a polynomial class that can be evaluated</span>
<span class="sd">            on a set of query points.</span>
<span class="sd">        xx : :class:`numpy:numpy.ndarray`</span>
<span class="sd">            The set of query points to evaluate as a two-dimensional array</span>
<span class="sd">            of shape ``(k, m)`` where ``k`` is the number of query points and</span>
<span class="sd">            ``m`` is the spatial dimension of the polynomial.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword-only arguments that change the behavior of</span>
<span class="sd">            the underlying evaluation (see the concrete implementation).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy:numpy.ndarray`</span>
<span class="sd">            The values of the polynomial evaluated at query points.</span>

<span class="sd">            - If there is only a single polynomial (i.e., a single set of</span>
<span class="sd">              coefficients), then a one-dimensional array of length ``k``</span>
<span class="sd">              is returned.</span>
<span class="sd">            - If there are multiple polynomials (i.e., multiple sets</span>
<span class="sd">              of coefficients), then a two-dimensional array of shape</span>
<span class="sd">              ``(k, np)`` is returned where ``np`` is the number of</span>
<span class="sd">              coefficient sets.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This is a placeholder of the ABC, which is overwritten</span>
<span class="sd">          by the concrete implementation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        __call__</span>
<span class="sd">            The dunder method as a syntactic sugar to evaluate</span>
<span class="sd">            the polynomial(s) instance on a set of query points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="MultivariatePolynomialABC.__call__">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialABC.__call__">[docs]</a>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate the polynomial on a set of query points.</span>

<span class="sd">        The function is called when an instance of a polynomial is called with</span>
<span class="sd">        a set of query points, i.e., :math:`p(\mathbf{X})` where</span>
<span class="sd">        :math:`\mathbf{X}` is a matrix of values with :math:`k` rows</span>
<span class="sd">        and each row is of length :math:`m` (i.e., a point in</span>
<span class="sd">        :math:`m`-dimensional space).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xx : :class:`numpy:numpy.ndarray`</span>
<span class="sd">            The set of query points to evaluate as a two-dimensional array</span>
<span class="sd">            of shape ``(k, m)`` where ``k`` is the number of query points and</span>
<span class="sd">            ``m`` is the spatial dimension of the polynomial.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword-only arguments that change the behavior of</span>
<span class="sd">            the underlying evaluation (see the concrete implementation).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy:numpy.ndarray`</span>
<span class="sd">            The values of the polynomial evaluated at query points.</span>

<span class="sd">            - If there is only a single polynomial (i.e., a single set of</span>
<span class="sd">              coefficients), then a one-dimensional array of length ``k``</span>
<span class="sd">              is returned.</span>
<span class="sd">            - If there are multiple polynomials (i.e., multiple sets</span>
<span class="sd">              of coefficients), then a two-dimensional array of shape</span>
<span class="sd">              ``(k, np)`` is returned where ``np`` is the number of</span>
<span class="sd">              coefficient sets.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The function calls the concrete implementation of the static method</span>
<span class="sd">          ``_eval()``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        _eval</span>
<span class="sd">            The underlying static method to evaluate the polynomial(s) instance</span>
<span class="sd">            on a set of query points.</span>

<span class="sd">        TODO</span>
<span class="sd">        ----</span>
<span class="sd">        - Possibly built-in rescaling between ``user_domain`` and</span>
<span class="sd">          ``internal_domain``. An idea: use sklearn min max scaler</span>
<span class="sd">          (``transform()`` and ``inverse_transform()``)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Verify query points</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="n">verify_query_points</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_dimension</span><span class="p">)</span>

        <span class="c1"># Evaluate using concrete static method</span>
        <span class="n">yy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Follow the convention of output shape from an evaluation</span>
        <span class="k">return</span> <span class="n">shape_eval_output</span><span class="p">(</span><span class="n">yy</span><span class="p">)</span></div>
</div>


    <span class="c1"># anything else any polynomial must support</span>
    <span class="c1"># TODO mathematical operations? abstract</span>
    <span class="c1"># TODO copy operations. abstract</span>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC">[docs]</a>
<span class="k">class</span> <span class="nc">MultivariatePolynomialSingleABC</span><span class="p">(</span><span class="n">MultivariatePolynomialABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;abstract base class for &quot;single instance&quot; multivariate polynomials</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    multi_index : MultiIndexSet</span>
<span class="sd">        The multi-indices of the multivariate polynomial.</span>
<span class="sd">    internal_domain : array_like</span>
<span class="sd">        The domain the polynomial is defined on (basically the domain of the unisolvent nodes).</span>
<span class="sd">        Either one-dimensional domain (min,max), a stack of domains for each</span>
<span class="sd">        domain with shape (spatial_dimension,2).</span>
<span class="sd">    user_domain : array_like</span>
<span class="sd">        The domain where the polynomial can be evaluated. This will be mapped onto the ``internal_domain``.</span>
<span class="sd">        Either one-dimensional domain ``min,max)`` a stack of domains for each</span>
<span class="sd">        domain with shape ``(spatial_dimension,2)``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    the grid with the corresponding indices defines the &quot;basis&quot; or polynomial space a polynomial is part of.</span>
<span class="sd">    e.g. also the constraints for a Lagrange polynomial, i.e. on which points they must vanish.</span>
<span class="sd">    ATTENTION: the grid might be defined on other indices than multi_index! e.g. useful for defining Lagrange coefficients with &quot;extra constraints&quot;</span>
<span class="sd">    but all indices from multi_index must be contained in the grid!</span>
<span class="sd">    this corresponds to polynomials with just some of the Lagrange polynomials of the basis being &quot;active&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># __doc__ += __doc_attrs__</span>

    <span class="n">_coeffs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ARRAY</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">generate_internal_domain</span><span class="p">(</span>
        <span class="n">internal_domain</span><span class="p">,</span> <span class="n">spatial_dimension</span>
    <span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="c1"># no docstring here, since it is given in the concrete implementation</span>
        <span class="k">pass</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">generate_user_domain</span><span class="p">(</span><span class="n">user_domain</span><span class="p">,</span> <span class="n">spatial_dimension</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="c1"># no docstring here, since it is given in the concrete implementation</span>
        <span class="k">pass</span>

    <span class="c1"># TODO static methods should not have a parameter &quot;self&quot;</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_add</span><span class="p">(</span><span class="n">poly_1</span><span class="p">,</span> <span class="n">poly_2</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="c1"># no docstring here, since it is given in the concrete implementation</span>
        <span class="k">pass</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="c1"># no docstring here, since it is given in the concrete implementation</span>
        <span class="k">pass</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_mul</span><span class="p">(</span><span class="n">poly_1</span><span class="p">,</span> <span class="n">poly_2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="c1"># no docstring here, since it is given in the concrete implementation</span>
        <span class="k">pass</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_div</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="c1"># no docstring here, since it is given in the concrete implementation</span>
        <span class="k">pass</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">pow</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="c1"># no docstring here, since it is given in the concrete implementation</span>
        <span class="k">pass</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_scalar_add</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">scalar</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="c1"># no docstring here, since it is given in the concrete implementation</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="MultivariatePolynomialSingleABC._gen_grid_default">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC._gen_grid_default">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_grid_default</span><span class="p">(</span><span class="n">multi_index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the default :class:`Grid` for a given :class:`MultiIndexSet` instance.</span>

<span class="sd">        For the default values of the Grid class, see :class:`minterpy.Grid`.</span>


<span class="sd">        :param multi_index: An instance of :class:`MultiIndexSet` for which the default :class:`Grid` shall be build</span>
<span class="sd">        :type multi_index: MultiIndexSet</span>
<span class="sd">        :return: An instance of :class:`Grid` with the default optional parameters.</span>
<span class="sd">        :rtype: Grid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Grid</span><span class="p">(</span><span class="n">multi_index</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC._partial_diff">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC._partial_diff">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_partial_diff</span><span class="p">(</span>
        <span class="n">poly</span><span class="p">:</span> <span class="n">MultivariatePolynomialABC</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Abstract method for differentiating poly. on a given dim. and order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        poly : MultivariatePolynomialABC</span>
<span class="sd">            The instance of polynomial to differentiate.</span>
<span class="sd">        dim : int</span>
<span class="sd">            Spatial dimension with respect to which the differentiation</span>
<span class="sd">            is taken. The dimension starts at 0 (i.e., the first dimension).</span>
<span class="sd">        order : int</span>
<span class="sd">            Order of partial derivative.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword-only arguments that change the behavior of</span>
<span class="sd">            the underlying differentiation (see the concrete implementation).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultivariatePolynomialSingleABC</span>
<span class="sd">            A new polynomial instance that represents the partial derivative</span>
<span class="sd">            of the original polynomial of the given order of derivative with</span>
<span class="sd">            respect to the specified dimension.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The concrete implementation of this static method is called when</span>
<span class="sd">          the public method ``partial_diff()`` is called on an instance.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        partial_diff</span>
<span class="sd">            The public method to differentiate the polynomial of a specified</span>
<span class="sd">            order of derivative with respect to a given dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC._diff">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC._diff">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_diff</span><span class="p">(</span>
        <span class="n">poly</span><span class="p">:</span> <span class="n">MultivariatePolynomialABC</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Abstract method for diff. poly. on given orders w.r.t each dim.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        poly : MultivariatePolynomialABC</span>
<span class="sd">            The instance of polynomial to differentiate.</span>
<span class="sd">        order : :class:`numpy:numpy.ndarray`</span>
<span class="sd">            A one-dimensional integer array specifying the orders of derivative</span>
<span class="sd">            along each dimension. The length of the array must be ``m`` where</span>
<span class="sd">            ``m`` is the spatial dimension of the polynomial.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword-only arguments that change the behavior of</span>
<span class="sd">            the underlying differentiation (see the concrete implementation).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultivariatePolynomialSingleABC</span>
<span class="sd">            A new polynomial instance that represents the partial derivative</span>
<span class="sd">            of the original polynomial of the specified orders of derivative</span>
<span class="sd">            along each dimension.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The concrete implementation of this static method is called when</span>
<span class="sd">          the public method ``diff()`` is called on an instance.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        diff</span>
<span class="sd">            The public method to differentiate the polynomial instance on</span>
<span class="sd">            the given orders of derivative along each dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC._integrate_over">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC._integrate_over">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_integrate_over</span><span class="p">(</span>
        <span class="n">poly</span><span class="p">:</span> <span class="s2">&quot;MultivariatePolynomialABC&quot;</span><span class="p">,</span>
        <span class="n">bounds</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Abstract method for definite integration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        poly : MultivariatePolynomialABC</span>
<span class="sd">            The instance of polynomial to integrate.</span>
<span class="sd">        bounds : Union[List[List[float]], np.ndarray], optional</span>
<span class="sd">            The bounds of the integral, an ``(m, 2)`` array where ``m``</span>
<span class="sd">            is the number of spatial dimensions. Each row corresponds to</span>
<span class="sd">            the bounds in a given dimension.</span>
<span class="sd">            If not given, then the canonical bounds :math:`[-1, 1]^m` will</span>
<span class="sd">            be used instead.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword-only arguments that change the behavior of</span>
<span class="sd">            the underlying integration (see the respective concrete</span>
<span class="sd">            implementations).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[:py:class:`float`, :class:`numpy:numpy.ndarray`]</span>
<span class="sd">            The integral value of the polynomial over the given bounds.</span>
<span class="sd">            If only one polynomial is available, the return value is of</span>
<span class="sd">            a :py:class:`float` type.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The concrete implementation of this static method is called when</span>
<span class="sd">          the public method ``integrate_over()`` is called on an instance.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        integrate_over</span>
<span class="sd">            The public method to integrate the polynomial instance over</span>
<span class="sd">            the given bounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


    <span class="c1"># --- Constructors</span>
<div class="viewcode-block" id="MultivariatePolynomialSingleABC.__init__">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">multi_index</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MultiIndexSet</span><span class="p">,</span> <span class="n">ARRAY</span><span class="p">],</span>
        <span class="n">coeffs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ARRAY</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">internal_domain</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ARRAY</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">user_domain</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ARRAY</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">grid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Grid</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="k">if</span> <span class="n">multi_index</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">MultiIndexSet</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">multi_index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;MultiIndexSet must not be empty!&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">multi_index</span> <span class="o">=</span> <span class="n">multi_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO should passing multi indices as ndarray be supported?</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">multi_index</span> <span class="o">=</span> <span class="n">MultiIndexSet</span><span class="p">(</span><span class="n">multi_index</span><span class="p">)</span>

        <span class="n">nr_monomials</span><span class="p">,</span> <span class="n">spatial_dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_index</span><span class="o">.</span><span class="n">exponents</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">=</span> <span class="n">coeffs</span>  <span class="c1"># calls the setter method and checks the input shape</span>

        <span class="k">if</span> <span class="n">internal_domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_type</span><span class="p">(</span><span class="n">internal_domain</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="n">check_values</span><span class="p">(</span><span class="n">internal_domain</span><span class="p">)</span>
            <span class="n">check_shape</span><span class="p">(</span><span class="n">internal_domain</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">spatial_dimension</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">internal_domain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_internal_domain</span><span class="p">(</span>
            <span class="n">internal_domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_index</span><span class="o">.</span><span class="n">spatial_dimension</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">user_domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># TODO not better &quot;external domain&quot;?!</span>
            <span class="n">check_type</span><span class="p">(</span><span class="n">user_domain</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="n">check_values</span><span class="p">(</span><span class="n">user_domain</span><span class="p">)</span>
            <span class="n">check_shape</span><span class="p">(</span><span class="n">user_domain</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">spatial_dimension</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_domain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_user_domain</span><span class="p">(</span>
            <span class="n">user_domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_index</span><span class="o">.</span><span class="n">spatial_dimension</span>
        <span class="p">)</span>

        <span class="c1"># TODO make multi_index input optional? otherwise use the indices from grid</span>
        <span class="c1"># TODO class method from_grid</span>
        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_grid_default</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multi_index</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Grid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span><span class="si">}</span><span class="s2"> of the input grid&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">grid</span><span class="o">.</span><span class="n">multi_index</span><span class="o">.</span><span class="n">is_superset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multi_index</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;the multi indices of a polynomial must be a subset of the indices of the grid in use&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span> <span class="n">Grid</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="c1"># weather or not the indices are independent from the grid (&quot;basis&quot;)</span>
        <span class="c1"># TODO this could be enconded by .active_monomials being None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indices_are_separate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">multi_index</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_monomials</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ARRAY</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># 1:1 correspondence</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices_are_separate</span><span class="p">:</span>
            <span class="c1"># store the position of the active Lagrange polynomials with respect to the basis indices:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">active_monomials</span> <span class="o">=</span> <span class="n">find_match_between</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">multi_index</span><span class="o">.</span><span class="n">exponents</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">multi_index</span><span class="o">.</span><span class="n">exponents</span>
            <span class="p">)</span></div>


    <span class="c1"># --- Factory methods</span>
<div class="viewcode-block" id="MultivariatePolynomialSingleABC.from_degree">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.from_degree">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_degree</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">spatial_dimension</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">poly_degree</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">lp_degree</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">coeffs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ARRAY</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">internal_domain</span><span class="p">:</span> <span class="n">ARRAY</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">user_domain</span><span class="p">:</span> <span class="n">ARRAY</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise Polynomial from given coefficients and the default construction for given polynomial degree, spatial dimension and :math:`l_p` degree.</span>

<span class="sd">        :param spatial_dimension: Dimension of the domain space of the polynomial.</span>
<span class="sd">        :type spatial_dimension: int</span>

<span class="sd">        :param poly_degree: The degree of the polynomial, i.e. the (integer) supremum of the :math:`l_p` norms of the monomials.</span>
<span class="sd">        :type poly_degree: int</span>

<span class="sd">        :param lp_degree: The :math:`l_p` degree used to determine the polynomial degree.</span>
<span class="sd">        :type lp_degree: int</span>

<span class="sd">        :param coeffs: coefficients of the polynomial. These shall be 1D for a single polynomial, where the length of the array is the number of monomials given by the ``multi_index``. For a set of similar polynomials (with the same number of monomials) the array can also be 2D, where the first axis refers to the monomials and the second axis refers to the polynomials.</span>
<span class="sd">        :type coeffs: np.ndarray</span>

<span class="sd">        :param internal_domain: the internal domain (factory) where the polynomials are defined on, e.g. :math:`[-1,1]^d` where :math:`d` is the dimension of the domain space. If a ``callable`` is passed, it shall get the dimension of the domain space and returns the ``internal_domain`` as an :class:`np.ndarray`.</span>
<span class="sd">        :type internal_domain: np.ndarray or callable</span>
<span class="sd">        :param user_domain: the domain window (factory), from which the arguments of a polynomial are transformed to the internal domain. If a ``callable`` is passed, it shall get the dimension of the domain space and returns the ``user_domain`` as an :class:`np.ndarray`.</span>
<span class="sd">        :type user_domain: np.ndarray or callable</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">MultiIndexSet</span><span class="o">.</span><span class="n">from_degree</span><span class="p">(</span><span class="n">spatial_dimension</span><span class="p">,</span> <span class="n">poly_degree</span><span class="p">,</span> <span class="n">lp_degree</span><span class="p">),</span>
            <span class="n">coeffs</span><span class="p">,</span>
            <span class="n">internal_domain</span><span class="p">,</span>
            <span class="n">user_domain</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC.from_poly">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.from_poly">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_poly</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">polynomial</span><span class="p">:</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">,</span>
        <span class="n">new_coeffs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ARRAY</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;constructs a new polynomial instance based on the properties of an input polynomial</span>

<span class="sd">        useful for copying polynomials of other types</span>


<span class="sd">        :param polynomial: input polynomial instance defining the properties to be reused</span>
<span class="sd">        :param new_coeffs: the coefficients the new polynomials should have. using `polynomial.coeffs` if `None`</span>
<span class="sd">        :return: new polynomial instance with equal properties</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The coefficients can also be assigned later.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">polynomial</span>
        <span class="k">if</span> <span class="n">new_coeffs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># use the same coefficients</span>
            <span class="n">new_coeffs</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">coeffs</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">multi_index</span><span class="p">,</span> <span class="n">new_coeffs</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">internal_domain</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">user_domain</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC.from_grid">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.from_grid">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_grid</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">grid</span><span class="p">:</span> <span class="n">Grid</span><span class="p">,</span>
        <span class="n">coeffs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">internal_domain</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">user_domain</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an instance of polynomial with a `Grid` instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grid : Grid</span>
<span class="sd">            The grid on which the polynomial is defined.</span>
<span class="sd">        coeffs : :class:`numpy:numpy.ndarray`, optional</span>
<span class="sd">            The coefficients of the polynomial(s); a one-dimensional array</span>
<span class="sd">            with the same length as the length of the multi-index set or</span>
<span class="sd">            a two-dimensional array with each column corresponds to the</span>
<span class="sd">            coefficients of a single polynomial on the same grid.</span>
<span class="sd">            This parameter is optional, if not specified the polynomial</span>
<span class="sd">            is considered &quot;uninitialized&quot;.</span>
<span class="sd">        internal_domain  : :class:`numpy:numpy.ndarray`, optional</span>
<span class="sd">            The internal domain of the polynomial(s).</span>
<span class="sd">        user_domain : :class:`numpy:numpy.ndarray`, optional</span>
<span class="sd">            The user domain of the polynomial(s).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultivariatePolynomialSingleABC</span>
<span class="sd">            An instance of polynomial defined on the given grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">multi_index</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="n">multi_index</span><span class="p">,</span>
            <span class="n">coeffs</span><span class="o">=</span><span class="n">coeffs</span><span class="p">,</span>
            <span class="n">internal_domain</span><span class="o">=</span><span class="n">internal_domain</span><span class="p">,</span>
            <span class="n">user_domain</span><span class="o">=</span><span class="n">user_domain</span><span class="p">,</span>
            <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="c1"># --- Properties</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The coefficients of the polynomial(s).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy:numpy.ndarray`</span>
<span class="sd">            One- or two-dimensional array that contains the polynomial</span>
<span class="sd">            coefficients. Coefficients of multiple polynomials having common</span>
<span class="sd">            structure are stored in a two-dimensional array of shape ``(N, P)``</span>
<span class="sd">            where ``N`` is the number of monomials and ``P`` is the number</span>
<span class="sd">            of polynomials.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the coefficients of an uninitialized polynomial are accessed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - ``coeffs`` may be assigned with `None` to indicate an uninitialized</span>
<span class="sd">           polynomial. Accessing such coefficients, however,</span>
<span class="sd">           raises an exception. Many operations involving polynomial instances,</span>
<span class="sd">           require the instance to be initialized and raising the exception</span>
<span class="sd">           here provides a common single point of failure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeffs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Coefficients of an uninitialized polynomial &quot;</span>
                <span class="s2">&quot;cannot be accessed.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeffs</span>

    <span class="nd">@coeffs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># setters shall not have docstrings. See numpydoc class example.</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># `None` indicates an uninitialized polynomial</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coeffs</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>

        <span class="c1"># Verify and assign the coefficient values</span>
        <span class="n">expected_num_monomials</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_active_monomials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coeffs</span> <span class="o">=</span> <span class="n">verify_poly_coeffs</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">expected_num_monomials</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_active_monomials</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of active monomials of the polynomial(s).</span>

<span class="sd">        The multi-index set that directly defines a polynomial and the grid</span>
<span class="sd">        (where the polynomial lives) may differ. Active monomials are</span>
<span class="sd">        the monomials that are defined by the multi-index set not by the one</span>
<span class="sd">        in the grid.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The number of active monomials.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multi_index</span><span class="p">)</span>

    <span class="c1"># --- Special methods: Rich comparison</span>
<div class="viewcode-block" id="MultivariatePolynomialSingleABC.__eq__">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.__eq__">[docs]</a>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compare two concrete polynomial instances for exact equality.</span>

<span class="sd">        Two polynomial instances are equal if and only if:</span>

<span class="sd">        - both are of the same concrete class, *and*</span>
<span class="sd">        - the underlying multi-index sets are equal, *and*</span>
<span class="sd">        - the underlying grid instances are equal, *and*</span>
<span class="sd">        - the coefficients of the polynomials are equal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : MultivariatePolynomialSingleABC</span>
<span class="sd">            Another instance of concrete implementation of</span>
<span class="sd">            `MultivariatePolynomialSingleABC` to compare with</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the current instance is equal to the other instance,</span>
<span class="sd">            ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The instances are of different concrete classes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># The underlying multi-index sets are equal</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_index</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">multi_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># The underlying grid instances are equal</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># The coefficients are both None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeffs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">_coeffs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># The coefficients of the polynomials are equal</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coeffs</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_coeffs</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>


    <span class="c1"># --- Special methods: Unary numeric</span>
<div class="viewcode-block" id="MultivariatePolynomialSingleABC.__neg__">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.__neg__">[docs]</a>
    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Negate the polynomial(s) instance.</span>

<span class="sd">        This function is called when a polynomial is negated via</span>
<span class="sd">        the ``-`` operator, e.g., ``-P``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultivariatePolynomialSingleABC</span>
<span class="sd">            New polynomial(s) instance with negated coefficients.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The resulting polynomial is a deep copy of the original polynomial.</span>
<span class="sd">        - ``-P`` is not the same as ``-1 * P``, the latter of which is a scalar</span>
<span class="sd">          multiplication. In this case, however, the result is the same;</span>
<span class="sd">          it returns a new instance with negated coefficients.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">self_copy</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">self_copy</span><span class="o">.</span><span class="n">_coeffs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">self_copy</span><span class="o">.</span><span class="n">_coeffs</span>

        <span class="k">return</span> <span class="n">self_copy</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC.__pos__">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.__pos__">[docs]</a>
    <span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plus sign the polynomial(s) instance.</span>

<span class="sd">        This function is called when a polynomial is plus signed via</span>
<span class="sd">        the ``+`` operator, e.g., ``+P``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultivariatePolynomialSingleABC</span>
<span class="sd">            The same polynomial</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - ``+P`` is not the same as ``1 * P``, the latter of which is a scalar</span>
<span class="sd">          multiplication. In this case, the result actually differs because</span>
<span class="sd">          the scalar multiplication ``1 * P`` returns a new instance of</span>
<span class="sd">          polynomial even though the coefficients are not altered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span></div>


    <span class="c1"># --- Special methods: Arithmetic operators</span>
<div class="viewcode-block" id="MultivariatePolynomialSingleABC.__add__">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.__add__">[docs]</a>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">,</span> <span class="n">SCALAR</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add the polynomial(s) with another polynomial(s) or a real scalar.</span>

<span class="sd">        This function is called when:</span>

<span class="sd">        - two polynomials are added: ``P1 + P2``, where ``P1`` (i.e., ``self``)</span>
<span class="sd">          and ``P2`` (``other``) are both instances of a concrete polynomial</span>
<span class="sd">          class.</span>
<span class="sd">        - a polynomial is added with a real scalar number: ``P1 + a``,</span>
<span class="sd">          where ``a`` (``other``) is a real scalar number.</span>

<span class="sd">        Polynomials are closed under scalar addition, meaning that</span>
<span class="sd">        the result of the addition is also a polynomial with the same</span>
<span class="sd">        underlying multi-index set; only the coefficients are altered.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Union[MultivariatePolynomialSingleABC, SCALAR]</span>
<span class="sd">            The right operand, either an instance of polynomial (of the same</span>
<span class="sd">            concrete class as the right operand) or a real scalar number.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultivariatePolynomialSingleABC</span>
<span class="sd">            The result of the addition, an instance of summed polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The concrete implementation of polynomial-polynomial and polynomial-</span>
<span class="sd">          scalar addition is delegated to the respective polynomial concrete</span>
<span class="sd">          class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle scalar addition</span>
        <span class="k">if</span> <span class="n">is_real_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scalar_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="c1"># Verify the operands before conducting addition</span>
        <span class="n">poly_1</span><span class="p">,</span> <span class="n">poly_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verify_operands</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">operation</span><span class="o">=</span><span class="s2">&quot;+ or -&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add</span><span class="p">(</span><span class="n">poly_1</span><span class="p">,</span> <span class="n">poly_2</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC.__sub__">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.__sub__">[docs]</a>
    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">,</span> <span class="n">SCALAR</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Subtract the polynomial(s) with another poly. or a real scalar.</span>

<span class="sd">        This function is called when:</span>

<span class="sd">        - two polynomials are subtracted: ``P1 - P2``, where ``P1`` and ``P2``</span>
<span class="sd">          are both instances of a concrete polynomial class.</span>
<span class="sd">        - a polynomial is added with a real scalar number: ``P1 - a``,</span>
<span class="sd">          where ``a`` is a real scalar number.</span>

<span class="sd">        Polynomials are closed under scalar subtraction, meaning that</span>
<span class="sd">        the result of the subtraction is also a polynomial with the same</span>
<span class="sd">        underlying multi-index set; only the coefficients are altered.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Union[MultivariatePolynomialSingleABC, SCALAR]</span>
<span class="sd">            The right operand, either an instance of polynomial (of the same</span>
<span class="sd">            concrete class as the right operand) or a real scalar number.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultivariatePolynomialSingleABC</span>
<span class="sd">            The result of the subtraction, an instance of subtracted</span>
<span class="sd">            polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Under the hood subtraction is an addition operation with a negated</span>
<span class="sd">          operand on the right; no separate concrete implementation is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle scalar addition</span>
        <span class="k">if</span> <span class="n">is_real_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scalar_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="n">other</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="o">-</span><span class="n">other</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC.__mul__">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.__mul__">[docs]</a>
    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">,</span> <span class="n">SCALAR</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Multiply the polynomial(s) with another polynomial or a real scalar.</span>

<span class="sd">        This function is called when:</span>

<span class="sd">        - two polynomials are multiplied: ``P1 * P2``, where ``P1`` and ``P2``</span>
<span class="sd">          are both instances of a concrete polynomial class.</span>
<span class="sd">        - a polynomial is multiplied with a real scalar number: ``P1 * a``,</span>
<span class="sd">          where ``a`` is a real scalar number.</span>

<span class="sd">        Polynomials are closed under scalar multiplication, meaning that</span>
<span class="sd">        the result of the multiplication is also a polynomial with the same</span>
<span class="sd">        underlying multi-index set; only the coefficients are altered.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Union[MultivariatePolynomialSingleABC, SCALAR]</span>
<span class="sd">            The right operand, either an instance of polynomial (of the same</span>
<span class="sd">            concrete class as the right operand) or a real scalar number.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultivariatePolynomialSingleABC</span>
<span class="sd">            The result of the multiplication, an instance of multiplied</span>
<span class="sd">            polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The concrete implementation of polynomial-polynomial multiplication</span>
<span class="sd">          is delegated to the respective polynomial concrete class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Multiplication by a real scalar number</span>
        <span class="k">if</span> <span class="n">is_real_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_scalar_mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="c1"># Verify the operands before conducting multiplication</span>
        <span class="n">poly_1</span><span class="p">,</span> <span class="n">poly_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verify_operands</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">operation</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mul</span><span class="p">(</span><span class="n">poly_1</span><span class="p">,</span> <span class="n">poly_2</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC.__truediv__">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.__truediv__">[docs]</a>
    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">SCALAR</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Divide an instance of polynomial with a real scalar number (``/``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Union[MultivariatePolynomialSingleABC, SCALAR]</span>
<span class="sd">            The right operand of the (true) division expression,</span>
<span class="sd">            a real scalar number.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultivariatePolynomialSingleABC</span>
<span class="sd">            An instance of polynomial, the result of (true) scalar division</span>
<span class="sd">            of a polynomial.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_real_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_scalar_truediv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_div</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC.__floordiv__">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.__floordiv__">[docs]</a>
    <span class="k">def</span> <span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">SCALAR</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Divide an instance of polynomial with a real scalar number (``//``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Union[MultivariatePolynomialSingleABC, SCALAR]</span>
<span class="sd">            The right operand of the (floor) division expression,</span>
<span class="sd">            a real scalar number.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultivariatePolynomialSingleABC</span>
<span class="sd">            An instance of polynomial, the result of (floor) scalar division</span>
<span class="sd">            of a polynomial.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_real_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_scalar_floordiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_div</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC.__pow__">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.__pow__">[docs]</a>
    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">power</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Take the polynomial instance to the given power.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        power : int</span>
<span class="sd">            The power in the exponentiation expression; the value must</span>
<span class="sd">            be a non-negative real scalar whole number. The value may not</span>
<span class="sd">            strictly be an integer as long as it is a whole number</span>
<span class="sd">            (e.g., :math:`2.0` is acceptable).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultivariatePolynomialSingleABC</span>
<span class="sd">            The result of exponentiation, an instance of a concrete polynomial</span>
<span class="sd">            class.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Exponentiation by zero returns a constant polynomial whose</span>
<span class="sd">          coefficients are zero except for the constant term with respect to</span>
<span class="sd">          the multi-index set which is given a value of :math:`1.0`.</span>
<span class="sd">          In the case of polynomials in the Lagrange basis whose no constant</span>
<span class="sd">          term with respect to the multi-index set, all coefficients are set to</span>
<span class="sd">          :math:`1.0`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if power is valid</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">verify_poly_power</span><span class="p">(</span><span class="n">power</span><span class="p">)</span>

        <span class="c1"># Iterative exponentiation</span>
        <span class="k">if</span> <span class="n">power</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">power</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">result</span></div>


    <span class="c1"># --- Special methods: Reversed arithmetic operation</span>
<div class="viewcode-block" id="MultivariatePolynomialSingleABC.__radd__">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.__radd__">[docs]</a>
    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">SCALAR</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Right-sided addition of the polynomial(s) with a real scalar number.</span>

<span class="sd">        This function is called for the expression ``a + P`` where ``a``</span>
<span class="sd">        and ``P`` is a real scalar number and an instance of polynomial,</span>
<span class="sd">        respectively.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : SCALAR</span>
<span class="sd">            A real scalar number (the left operand) to be added to</span>
<span class="sd">            the polynomial.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultivariatePolynomialSingleABC</span>
<span class="sd">            The result of adding the scalar value to the polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If the left operand is not a real scalar number, the right-sided</span>
<span class="sd">          addition is not explicitly supported, and it will rely on</span>
<span class="sd">          the `__add__()` method of the left operand.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Addition of a real scalar number by a polynomial</span>
        <span class="k">if</span> <span class="n">is_real_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scalar_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="c1"># Right-sided addition with other types is not explicitly supported;</span>
        <span class="c1"># it will rely on the left operand &#39;__add__()&#39; method</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC.__rsub__">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.__rsub__">[docs]</a>
    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">SCALAR</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Right-sided subtraction of the polynomial(s) with a real scalar.</span>

<span class="sd">        This function is called for the expression ``a - P`` where ``a``</span>
<span class="sd">        and ``P`` is a real scalar number and an instance of polynomial,</span>
<span class="sd">        respectively.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : SCALAR</span>
<span class="sd">            A real scalar number (the left operand) to be substracted by</span>
<span class="sd">            the polynomial.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultivariatePolynomialSingleABC</span>
<span class="sd">            The result of subtracting a scalar value by the polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If the left operand is not a real scalar number, the right-sided</span>
<span class="sd">          subtraction is not explicitly supported, and it will rely on</span>
<span class="sd">          the `__add__()` method of the left operand.</span>
<span class="sd">        - This operation relies on the negation of a polynomial and scalar</span>
<span class="sd">          addition</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Subtraction of a real scalar number by a polynomial</span>
        <span class="k">if</span> <span class="n">is_real_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scalar_add</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="c1"># Right-sided subtraction with other types is not explicitly supported;</span>
        <span class="c1"># it will rely on the left operand &#39;__sub__()&#39; method</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC.__rmul__">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.__rmul__">[docs]</a>
    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">SCALAR</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Right sided multiplication of the polynomial(s) with a real scalar.</span>

<span class="sd">        This function is called if a real scalar number is multiplied</span>
<span class="sd">        with a polynomial like ``a * P`` where ``a`` and ``P`` are a scalar</span>
<span class="sd">        and a polynomial instance, respectively.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : SCALAR</span>
<span class="sd">            The left operand, a real scalar number.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultivariatePolynomialSingleABC</span>
<span class="sd">            The result of the multiplication, an instance of multiplied</span>
<span class="sd">            polynomial.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Multiplication by a real scalar number</span>
        <span class="k">if</span> <span class="n">is_real_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_scalar_mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="c1"># Right-sided multiplication with other types is not explicitly</span>
        <span class="c1"># supported; it will rely on the left operand &#39;__mul__()&#39; method</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span></div>


    <span class="c1"># --- Special methods: copies</span>
<div class="viewcode-block" id="MultivariatePolynomialSingleABC.__copy__">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.__copy__">[docs]</a>
    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates of a shallow copy.</span>

<span class="sd">        This function is called, if one uses the top-level function ``copy()`` on an instance of this class.</span>

<span class="sd">        :return: The copy of the current instance.</span>
<span class="sd">        :rtype: MultivariatePolynomialSingleABC</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        copy.copy</span>
<span class="sd">            copy operator form the python standard library.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">multi_index</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coeffs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">internal_domain</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">user_domain</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC.__deepcopy__">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.__deepcopy__">[docs]</a>
    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mem</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates of a deepcopy.</span>

<span class="sd">        This function is called, if one uses the top-level function ``deepcopy()`` on an instance of this class.</span>

<span class="sd">        :return: The deepcopy of the current instance.</span>
<span class="sd">        :rtype: MultivariatePolynomialSingleABC</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        copy.deepcopy</span>
<span class="sd">            copy operator form the python standard library.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multi_index</span><span class="p">),</span>
            <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coeffs</span><span class="p">),</span>
            <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internal_domain</span><span class="p">),</span>
            <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user_domain</span><span class="p">),</span>
            <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">),</span>
        <span class="p">)</span></div>


    <span class="c1"># Special methods: Collection emulation</span>
<div class="viewcode-block" id="MultivariatePolynomialSingleABC.__len__">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.__len__">[docs]</a>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of polynomials in the instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The number of polynomial in the instance. A single instance of</span>
<span class="sd">            polynomial may contain multiple polynomials with different</span>
<span class="sd">            coefficient values but sharing the same underlying multi-index set</span>
<span class="sd">            and grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spatial_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Spatial dimension.</span>

<span class="sd">        The dimension of space where the polynomial(s) live on.</span>

<span class="sd">        :return: Dimension of domain space.</span>
<span class="sd">        :rtype: int</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is propagated from the ``multi_index.spatial_dimension``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_index</span><span class="o">.</span><span class="n">spatial_dimension</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unisolvent_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unisolvent nodes the polynomial(s) is(are) defined on.</span>

<span class="sd">        For definitions of unisolvent nodes see the mathematical introduction.</span>

<span class="sd">        :return: Array of unisolvent nodes.</span>
<span class="sd">        :rtype: np.ndarray</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is propagated from from ``self.grid.unisolvent_nodes``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">unisolvent_nodes</span>

    <span class="c1"># --- Instance methods</span>
<div class="viewcode-block" id="MultivariatePolynomialSingleABC._new_instance_if_necessary">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC._new_instance_if_necessary">[docs]</a>
    <span class="k">def</span> <span class="nf">_new_instance_if_necessary</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">new_grid</span><span class="p">,</span> <span class="n">new_indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MultiIndexSet</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructs a new instance only if the multi indices have changed.</span>

<span class="sd">        :param new_grid: Grid instance the polynomial is defined on.</span>
<span class="sd">        :type new_grid: Grid</span>

<span class="sd">        :param new_indices: :class:`MultiIndexSet` instance for the polynomial(s), needs to be a subset of the current ``multi_index``. Default is :class:`None`.</span>
<span class="sd">        :type new_indices: MultiIndexSet, optional</span>

<span class="sd">        :return: Same polynomial instance if ``grid`` and ``multi_index`` stay the same, otherwise new polynomial instance with the new ``grid`` and ``multi_index``.</span>
<span class="sd">        :rtype: MultivariatePolynomialSingleABC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prev_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        <span class="k">if</span> <span class="n">new_grid</span> <span class="ow">is</span> <span class="n">prev_grid</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="c1"># grid has changed</span>
        <span class="k">if</span> <span class="n">new_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># the active monomials (and coefficients) stay equal</span>
            <span class="n">new_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_index</span>
            <span class="n">new_coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeffs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># also the active monomials change</span>
            <span class="n">prev_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_index</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">prev_indices</span><span class="o">.</span><span class="n">is_subset</span><span class="p">(</span><span class="n">new_indices</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;an index set of a polynomial can only be expanded, &quot;</span>
                    <span class="s2">&quot;but the old indices contain multi indices not present in the new indices.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># convert the coefficients correctly:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeffs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_coeffs</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_indices</span><span class="p">))</span>
                <span class="n">idxs_of_old</span> <span class="o">=</span> <span class="n">find_match_between</span><span class="p">(</span>
                    <span class="n">prev_indices</span><span class="o">.</span><span class="n">exponents</span><span class="p">,</span> <span class="n">new_indices</span><span class="o">.</span><span class="n">exponents</span>
                <span class="p">)</span>
                <span class="n">new_coeffs</span><span class="p">[</span><span class="n">idxs_of_old</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeffs</span>

        <span class="n">new_poly_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_indices</span><span class="p">,</span> <span class="n">new_coeffs</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">new_grid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_poly_instance</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC.make_complete">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.make_complete">[docs]</a>
    <span class="k">def</span> <span class="nf">make_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;returns a possibly new polynomial instance with a complete multi index set.</span>

<span class="sd">        :return: completed polynomial, where additional coefficients setted to zero.</span>
<span class="sd">        :rtype: MultivariatePolynomialSingleABC</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - the active monomials stay equal. only the grid (&quot;basis&quot;) changes</span>
<span class="sd">        - in the case of a Lagrange polynomial this could be done by evaluating the polynomial on the complete grid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid_completed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">make_complete</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_instance_if_necessary</span><span class="p">(</span><span class="n">grid_completed</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC.add_points">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.add_points">[docs]</a>
    <span class="k">def</span> <span class="nf">add_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exponents</span><span class="p">:</span> <span class="n">ARRAY</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extend ``grid`` and ``multi_index``</span>

<span class="sd">        Adds points ``grid`` and exponents to ``multi_index`` related to a given set of additional exponents.</span>

<span class="sd">        :param exponents: Array of exponents added.</span>
<span class="sd">        :type exponents: np.ndarray</span>

<span class="sd">        :return: New polynomial with the added exponents.</span>
<span class="sd">        :rtype: MultivariatePolynomialSingleABC</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># replace the grid with an independent copy with the new multi indices</span>
        <span class="c1"># ATTENTION: the grid might be defined on other indices than multi_index!</span>
        <span class="c1">#   but all indices from multi_index must be contained in the grid!</span>
        <span class="c1"># -&gt; make sure to add all new additional indices also to the grid!</span>
        <span class="n">grid_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">add_exponents</span><span class="p">(</span><span class="n">exponents</span><span class="p">)</span>
        <span class="n">multi_indices_new</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices_are_separate</span><span class="p">:</span>
            <span class="n">multi_indices_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_index</span><span class="o">.</span><span class="n">add_exponents</span><span class="p">(</span><span class="n">exponents</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_instance_if_necessary</span><span class="p">(</span><span class="n">grid_new</span><span class="p">,</span> <span class="n">multi_indices_new</span><span class="p">)</span></div>


    <span class="c1"># def make_derivable(self) -&gt; &quot;MultivariatePolynomialSingleABC&quot;:</span>
    <span class="c1">#     &quot;&quot;&quot; convert the polynomial into a new polynomial instance with a &quot;derivable&quot; multi index set</span>
    <span class="c1">#  NOTE: not meaningful since derivation requires complete index sets anyway?</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     new_indices = self.multi_index.make_derivable()</span>
    <span class="c1">#     return self._new_instance_if_necessary(new_indices)</span>

<div class="viewcode-block" id="MultivariatePolynomialSingleABC.expand_dim">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.expand_dim">[docs]</a>
    <span class="k">def</span> <span class="nf">expand_dim</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target_dimension</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">extra_internal_domain</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_user_domain</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Expand the spatial dimension of the polynomial instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target_dimension : Union[int, MultivariatePolynomialSingleABC]</span>
<span class="sd">            The new spatial dimension. It must be larger than or equal to</span>
<span class="sd">            the current dimension of the polynomial. Alternatively, another</span>
<span class="sd">            instance of polynomial that has a higher dimension, a consistent</span>
<span class="sd">            underlying `Grid` instance is consistent, and a matching domain</span>
<span class="sd">            can also be specified as a target dimension.</span>
<span class="sd">        extra_internal_domain : :class:`numpy:numpy.ndarray`, optional</span>
<span class="sd">            The additional internal domains for the expanded polynomial.</span>
<span class="sd">            This parameter is optional; if not specified, the values are either</span>
<span class="sd">            taken from the domain of the higher-dimensional polynomial or</span>
<span class="sd">            from the domain of the other dimensions.</span>
<span class="sd">        extra_user_domain : :class:`numpy:numpy.ndarray`, optional</span>
<span class="sd">            The additional user domains for the expanded polynomial.</span>
<span class="sd">            This parameter is optional; if not specified, the values are either</span>
<span class="sd">            taken from the domain of the higher-dimensional polynomial or</span>
<span class="sd">            from the domain of the other dimensions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultivariatePolynomialSingleABC</span>
<span class="sd">            A new instance of polynomial whose spatial dimension has been</span>
<span class="sd">            expanded to the target.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the target dimension is an `int`, the exception is raised</span>
<span class="sd">            when the user or internal domains cannot be extrapolated to</span>
<span class="sd">            a higher dimension. If the target dimension is an instance of</span>
<span class="sd">            `MultivariatePolynomialSingleABC`, the exception is raised when</span>
<span class="sd">            the user or internal domains do no match.</span>
<span class="sd">            In both cases, an exception may also be raised by attempting</span>
<span class="sd">            to expand the dimension of the underlying `Grid` or `MultiIndexSet`</span>
<span class="sd">            instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_dimension</span><span class="p">,</span> <span class="n">MultivariatePolynomialSingleABC</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_expand_dim_to_target_poly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_dimension</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_expand_dim_to_target_dim</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">target_dimension</span><span class="p">,</span>
            <span class="n">extra_internal_domain</span><span class="p">,</span>
            <span class="n">extra_user_domain</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC.partial_diff">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.partial_diff">[docs]</a>
    <span class="k">def</span> <span class="nf">partial_diff</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the partial derivative poly. at the given dim. and order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int</span>
<span class="sd">            Spatial dimension with respect to which the differentiation</span>
<span class="sd">            is taken. The dimension starts at 0 (i.e., the first dimension).</span>
<span class="sd">        order : int</span>
<span class="sd">            Order of partial derivative.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword-only arguments that change the behavior of</span>
<span class="sd">            the underlying differentiation (see the respective concrete</span>
<span class="sd">            implementations).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultivariatePolynomialSingleABC</span>
<span class="sd">            A new polynomial instance that represents the partial derivative</span>
<span class="sd">            of the original polynomial of the specified order of derivative</span>
<span class="sd">            and with respect to the specified dimension.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method calls the concrete implementation of the abstract</span>
<span class="sd">          method ``_partial_diff()`` after input validation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        _partial_diff</span>
<span class="sd">            The underlying static method to differentiate the polynomial</span>
<span class="sd">            instance of a specified order of derivative and with respect to</span>
<span class="sd">            a specified dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Guard rails for dim</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dim &lt;</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">&gt; must be an integer&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">dim</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_dimension</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;dim &lt;</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">&gt; for spatial dimension &lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_dimension</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; should be between 0 and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_dimension</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Guard rails for order</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;order &lt;</span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">&gt; must be a non-negative integer&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">order</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;order &lt;</span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">&gt; must be a non-negative integer&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_partial_diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC.diff">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.diff">[docs]</a>
    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the partial derivative poly. of given orders along each dim.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : :class:`numpy:numpy.ndarray`</span>
<span class="sd">            A one-dimensional integer array specifying the orders of derivative</span>
<span class="sd">            along each dimension. The length of the array must be ``m`` where</span>
<span class="sd">            ``m`` is the spatial dimension of the polynomial.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword-only arguments that change the behavior of</span>
<span class="sd">            the underlying differentiation (see the respective concrete</span>
<span class="sd">            implementations).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultivariatePolynomialSingleABC</span>
<span class="sd">            A new polynomial instance that represents the partial derivative</span>
<span class="sd">            of the original polynomial of the specified orders of derivative</span>
<span class="sd">            along each dimension.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method calls the concrete implementation of the abstract</span>
<span class="sd">          method ``_diff()`` after input validation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        _diff</span>
<span class="sd">            The underlying static method to differentiate the polynomial</span>
<span class="sd">            of specified orders of derivative along each dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># convert &#39;order&#39; to numpy 1d array if it isn&#39;t already. This allows type checking below.</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>

        <span class="c1"># Guard rails for order</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">order</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;order of derivative &lt;</span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">&gt; can only be non-negative integers&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">order</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;order of derivative &lt;</span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">&gt; cannot have negative values&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_dimension</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;inconsistent number of elements in &#39;order&#39; &lt;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)</span><span class="si">}</span><span class="s2">&gt;,&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;expected &lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_dimension</span><span class="si">}</span><span class="s2">&gt; corresponding to each spatial dimension&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC.integrate_over">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.integrate_over">[docs]</a>
    <span class="k">def</span> <span class="nf">integrate_over</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bounds</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the definite integral of the polynomial over the bounds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bounds : Union[List[List[float]], np.ndarray], optional</span>
<span class="sd">            The bounds of the integral, an ``(m, 2)`` array where ``m``</span>
<span class="sd">            is the number of spatial dimensions. Each row corresponds to</span>
<span class="sd">            the bounds in a given dimension.</span>
<span class="sd">            If not given, then the canonical bounds :math:`[-1, 1]^m` will</span>
<span class="sd">            be used instead.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword-only arguments that change the behavior of</span>
<span class="sd">            the underlying integration (see the respective concrete</span>
<span class="sd">            implementations).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[:py:class:`float`, :class:`numpy:numpy.ndarray`]</span>
<span class="sd">            The integral value of the polynomial over the given bounds.</span>
<span class="sd">            If only one polynomial is available, the return value is of</span>
<span class="sd">            a :py:class:`float` type.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the bounds either of inconsistent shape or not in</span>
<span class="sd">            the :math:`[-1, 1]^m` domain.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method calls the concrete implementation of the abstract</span>
<span class="sd">          method ``_integrate_over()`` after input validation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        _integrate_over</span>
<span class="sd">            The underlying static method to integrate the polynomial instance</span>
<span class="sd">            over the given bounds.</span>

<span class="sd">        TODO</span>
<span class="sd">        ----</span>
<span class="sd">        - The default fixed domain [-1, 1]^M may in the future be relaxed.</span>
<span class="sd">          In that case, the domain check below along with the concrete</span>
<span class="sd">          implementations for the poly. classes must be updated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_dimension</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># The canonical bounds are [-1, 1]^M</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">num_dim</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">bounds</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>

        <span class="c1"># --- Bounds verification</span>
        <span class="c1"># Shape</span>
        <span class="k">if</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">num_dim</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The bounds shape is inconsistent! &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Given </span><span class="si">{</span><span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, expected </span><span class="si">{</span><span class="p">(</span><span class="n">num_dim</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Domain fit, i.e., in [-1, 1]^M</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">bounds</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">bounds</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bounds are outside [-1, 1]^M domain!&quot;</span><span class="p">)</span>

        <span class="c1"># --- Compute the integrals</span>
        <span class="c1"># If the lower and upper bounds are equal, immediately return 0</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">bounds</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])):</span>
            <span class="k">return</span> <span class="mf">0.0</span>

        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_integrate_over</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># One-element array (one set of coefficients), just return the item</span>
            <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span></div>


    <span class="c1"># --- Public utility methods</span>
<div class="viewcode-block" id="MultivariatePolynomialSingleABC.has_matching_dimension">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.has_matching_dimension">[docs]</a>
    <span class="k">def</span> <span class="nf">has_matching_dimension</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``True`` if the polynomials have matching dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : MultivariatePolynomialSingleABC</span>
<span class="sd">            The second instance of polynomial to compare.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the two spatial dimensions match, ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_dimension</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">spatial_dimension</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC.has_matching_domain">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC.has_matching_domain">[docs]</a>
    <span class="k">def</span> <span class="nf">has_matching_domain</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-16</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``True`` if the polynomials have matching domains.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : MultivariatePolynomialSingleABC</span>
<span class="sd">            The second instance of polynomial to compare.</span>
<span class="sd">        tol : float, optional</span>
<span class="sd">            The tolerance used to check for matching domains.</span>
<span class="sd">            Default is 1e-16.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the two domains match, ``False`` otherwise.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The method checks both the internal and user domains.</span>
<span class="sd">        - If the dimensions of the polynomials do not match, the comparison</span>
<span class="sd">          is carried out up to the smallest matching dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the dimension to deal with unmatching dimension</span>
        <span class="n">dim_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_dimension</span>
        <span class="n">dim_2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">spatial_dimension</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">dim_1</span><span class="p">,</span> <span class="n">dim_2</span><span class="p">])</span>  <span class="c1"># Check up to the smallest matching dim.</span>

        <span class="c1"># Check matching internal domain</span>
        <span class="n">internal_domain_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_domain</span><span class="p">[:,</span> <span class="p">:</span><span class="n">dim</span><span class="p">]</span>
        <span class="n">internal_domain_2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">internal_domain</span><span class="p">[:,</span> <span class="p">:</span><span class="n">dim</span><span class="p">]</span>
        <span class="n">has_matching_internal_domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">internal_domain_1</span> <span class="o">-</span> <span class="n">internal_domain_2</span><span class="p">),</span>
            <span class="n">tol</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Check matching user domain</span>
        <span class="n">user_domain_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_domain</span><span class="p">[:,</span> <span class="p">:</span><span class="n">dim</span><span class="p">]</span>
        <span class="n">user_domain_2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">user_domain</span><span class="p">[:,</span> <span class="p">:</span><span class="n">dim</span><span class="p">]</span>
        <span class="n">has_matching_user_domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">user_domain_1</span> <span class="o">-</span> <span class="n">user_domain_2</span><span class="p">),</span>
            <span class="n">tol</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Checking both domains</span>
        <span class="n">has_matching_domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">has_matching_internal_domain</span><span class="p">,</span>
            <span class="n">has_matching_user_domain</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">has_matching_domain</span><span class="p">)</span></div>


    <span class="c1"># --- Private utility methods: Not supposed to be called from the outside</span>
<div class="viewcode-block" id="MultivariatePolynomialSingleABC._match_dims">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC._match_dims">[docs]</a>
    <span class="k">def</span> <span class="nf">_match_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
        <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">,</span>
        <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">,</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Match the dimension of two polynomials.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : MultivariatePolynomialSingleABC</span>
<span class="sd">            An instance polynomial whose dimension is to match with the current</span>
<span class="sd">            polynomial instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[MultivariatePolynomialSingleABC, MultivariatePolynomialSingleABC]</span>
<span class="sd">            The two instances of polynomials whose dimensions have been</span>
<span class="sd">            matched.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the dimension of one of the polynomial instance can&#39;t be</span>
<span class="sd">            matched due to, for instance, incompatible domain.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If both polynomials have matching dimension and domains, then</span>
<span class="sd">          the function return the two polynomials as they are.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_matching_dimension</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">has_matching_domain</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="c1"># Dimension and domain match, no need to do anything</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span>

        <span class="c1"># Otherwise expand the lower dimension polynomial to a higher dimension</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_dimension</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">spatial_dimension</span><span class="p">:</span>
            <span class="n">other_expanded</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">expand_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other_expanded</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">self_expanded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_dim</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">self_expanded</span><span class="p">,</span> <span class="n">other</span></div>


<div class="viewcode-block" id="MultivariatePolynomialSingleABC._verify_operands">
<a class="viewcode-back" href="../../../../api/core/ABC/abc-polynomial.html#minterpy.core.ABC.multivariate_polynomial_abstract.MultivariatePolynomialSingleABC._verify_operands">[docs]</a>
    <span class="k">def</span> <span class="nf">_verify_operands</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">,</span>
        <span class="n">operation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
         <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">,</span>
         <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">,</span>
         <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Verify the operands are valid before moving on.&quot;&quot;&quot;</span>
        <span class="c1"># Only supported for polynomials of the same concrete class</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unsupported operand type(s) for </span><span class="si">{</span><span class="n">operation</span><span class="si">}</span><span class="s2">: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Check if the number of coefficients is consistent</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot add polynomials with inconsistent &quot;</span>
                <span class="s2">&quot;number of coefficient sets&quot;</span>
            <span class="p">)</span>

        <span class="n">poly_1</span><span class="p">,</span> <span class="n">poly_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_dims</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">poly_1</span><span class="p">,</span> <span class="n">poly_2</span></div>
</div>



<span class="k">def</span> <span class="nf">_scalar_mul</span><span class="p">(</span>
    <span class="n">poly</span><span class="p">:</span> <span class="n">MultivariatePolynomialSingleABC</span><span class="p">,</span>
    <span class="n">scalar</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SCALAR</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MultivariatePolynomialSingleABC</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Multiply the polynomial by a (real) scalar value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    poly : MultivariatePolynomialSingleABC</span>
<span class="sd">        The polynomial instance to be multiplied.</span>
<span class="sd">    scalar : Union[SCALAR, np.ndarray]</span>
<span class="sd">        The real scalar value to multiply the polynomial by.</span>
<span class="sd">        Multiple scalars may be specified as an array as long as the length</span>
<span class="sd">        is consistent with the length of the polynomial instance.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    MultivariatePolynomialSingleABC</span>
<span class="sd">        The multiplied polynomial.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This is a concrete implementation applicable to all concrete</span>
<span class="sd">      implementations of polynomial due to the universal rule of</span>
<span class="sd">      scalar-polynomial multiplication.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">poly_copy</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
    <span class="n">poly_copy</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">*=</span> <span class="n">scalar</span>

    <span class="k">return</span> <span class="n">poly_copy</span>


<span class="k">def</span> <span class="nf">_scalar_truediv</span><span class="p">(</span>
    <span class="n">poly</span><span class="p">:</span> <span class="n">MultivariatePolynomialSingleABC</span><span class="p">,</span>
    <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SCALAR</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MultivariatePolynomialSingleABC</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;True divide the polynomial by a real scalar value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    poly : MultivariatePolynomialSingleABC</span>
<span class="sd">        The polynomial instance to be divided.</span>
<span class="sd">    scalar : Union[SCALAR, np.ndarray]</span>
<span class="sd">        The real scalar value to divide the polynomial by.</span>
<span class="sd">        Multiple scalars may be specified as an array as long as the length</span>
<span class="sd">        is consistent with the length of the polynomial instance.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    MultivariatePolynomialSingleABC</span>
<span class="sd">        The divided polynomial.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This is a concrete implementation applicable to all concrete</span>
<span class="sd">      implementations of polynomial due to the universal rule of</span>
<span class="sd">      polynomial-scalar division.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">poly_copy</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
    <span class="n">poly_copy</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">/=</span> <span class="n">other</span>

    <span class="k">return</span> <span class="n">poly_copy</span>


<span class="k">def</span> <span class="nf">_scalar_floordiv</span><span class="p">(</span>
    <span class="n">poly</span><span class="p">:</span> <span class="n">MultivariatePolynomialSingleABC</span><span class="p">,</span>
    <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SCALAR</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MultivariatePolynomialSingleABC</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Floor divide the polynomial by a real scalar value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    poly : MultivariatePolynomialSingleABC</span>
<span class="sd">        The polynomial instance to be divided.</span>
<span class="sd">    scalar : Union[SCALAR, np.ndarray]</span>
<span class="sd">        The real scalar value to divide the polynomial by.</span>
<span class="sd">        Multiple scalars may be specified as an array as long as the length</span>
<span class="sd">        is consistent with the length of the polynomial instance.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    MultivariatePolynomialSingleABC</span>
<span class="sd">        The divided polynomial.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This is a concrete implementation applicable to all concrete</span>
<span class="sd">      implementations of polynomial due to the universal rule of</span>
<span class="sd">      polynomial-scalar division.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">poly_copy</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
    <span class="n">poly_copy</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">//=</span> <span class="n">other</span>

    <span class="k">return</span> <span class="n">poly_copy</span>


<span class="k">def</span> <span class="nf">_has_consistent_number_of_polys</span><span class="p">(</span>
    <span class="n">poly_1</span><span class="p">:</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">,</span>
    <span class="n">poly_2</span><span class="p">:</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if two polynomials have a consistent number of coefficient sets.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coeffs_1</span> <span class="o">=</span> <span class="n">poly_1</span><span class="o">.</span><span class="n">coeffs</span>
    <span class="n">coeffs_2</span> <span class="o">=</span> <span class="n">poly_2</span><span class="o">.</span><span class="n">coeffs</span>

    <span class="n">ndim_1</span> <span class="o">=</span> <span class="n">coeffs_1</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">ndim_2</span> <span class="o">=</span> <span class="n">coeffs_2</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ndim_1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ndim_2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="n">has_same_dims</span> <span class="o">=</span> <span class="n">coeffs_1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">coeffs_2</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">has_same_cols</span> <span class="o">=</span> <span class="n">coeffs_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">coeffs_2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">has_same_dims</span> <span class="ow">and</span> <span class="n">has_same_cols</span>


<span class="k">def</span> <span class="nf">_expand_dim_to_target_poly</span><span class="p">(</span>
    <span class="n">origin_poly</span><span class="p">:</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">,</span>
    <span class="n">target_poly</span><span class="p">:</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Expand the dimension of the polynomial to the dimension of another.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    origin_poly : MultivariatePolynomialSingleABC</span>
<span class="sd">        The polynomial whose spatial dimension is to be expanded.</span>
<span class="sd">    target_poly : MultivariatePolynomialSingleABC</span>
<span class="sd">        The polynomial whose spatial dimension is the target dimension.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    MultivariatePolynomialSingleABC</span>
<span class="sd">        A new instance of polynomial with an expanded dimension.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The extra internal and user domains of the resulting instance takes</span>
<span class="sd">      the values from the target polynomial.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">origin_poly</span><span class="o">.</span><span class="n">has_matching_domain</span><span class="p">(</span><span class="n">target_poly</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Polynomial cannot be expanded to the dimension of the target &quot;</span>
            <span class="s2">&quot;due to non-matching domain.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Domains and dimensions match: return a copy</span>
    <span class="k">if</span> <span class="n">origin_poly</span><span class="o">.</span><span class="n">has_matching_dimension</span><span class="p">(</span><span class="n">target_poly</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">copy</span><span class="p">(</span><span class="n">origin_poly</span><span class="p">)</span>

    <span class="c1"># Otherwise: expand the dimension</span>

    <span class="c1"># Get the dimensions</span>
    <span class="n">origin_dimension</span> <span class="o">=</span> <span class="n">origin_poly</span><span class="o">.</span><span class="n">spatial_dimension</span>
    <span class="n">target_dimension</span> <span class="o">=</span> <span class="n">target_poly</span><span class="o">.</span><span class="n">spatial_dimension</span>

    <span class="c1"># Expand the dimension underlying multi-index set to the target dimension</span>
    <span class="n">mi</span> <span class="o">=</span> <span class="n">origin_poly</span><span class="o">.</span><span class="n">multi_index</span><span class="o">.</span><span class="n">expand_dim</span><span class="p">(</span><span class="n">target_dimension</span><span class="p">)</span>

    <span class="c1"># Expand the dimension of the underlying grid to the target grid</span>
    <span class="n">grd</span> <span class="o">=</span> <span class="n">origin_poly</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">expand_dim</span><span class="p">(</span><span class="n">target_poly</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>

    <span class="c1"># Expand the dimension of the internal domain (use values from the larger)</span>
    <span class="n">origin_internal_domain</span> <span class="o">=</span> <span class="n">origin_poly</span><span class="o">.</span><span class="n">internal_domain</span>
    <span class="n">target_internal_domain</span> <span class="o">=</span> <span class="n">target_poly</span><span class="o">.</span><span class="n">internal_domain</span>
    <span class="n">internal_domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span>
        <span class="n">origin_internal_domain</span><span class="p">,</span>
        <span class="n">target_internal_domain</span><span class="p">[:,</span> <span class="n">origin_dimension</span><span class="p">:],</span>
    <span class="p">]</span>

    <span class="c1"># Expand the dimension of the user domain (use values from the larger)</span>
    <span class="n">origin_user_domain</span> <span class="o">=</span> <span class="n">origin_poly</span><span class="o">.</span><span class="n">user_domain</span>
    <span class="n">target_user_domain</span> <span class="o">=</span> <span class="n">target_poly</span><span class="o">.</span><span class="n">user_domain</span>
    <span class="n">user_domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span>
        <span class="n">origin_user_domain</span><span class="p">,</span>
        <span class="n">target_user_domain</span><span class="p">[:,</span> <span class="n">origin_dimension</span><span class="p">:],</span>
    <span class="p">]</span>

    <span class="c1"># NOTE: There is no need to verify the domains again because they are</span>
    <span class="c1"># taken from the properties of polynomial instances (already verified)</span>

    <span class="c1"># Return a new instance</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># The instance is initialized with coefficients</span>
        <span class="k">return</span> <span class="n">origin_poly</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">multi_index</span><span class="o">=</span><span class="n">mi</span><span class="p">,</span>
            <span class="n">coeffs</span><span class="o">=</span><span class="n">origin_poly</span><span class="o">.</span><span class="n">coeffs</span><span class="p">,</span>
            <span class="n">internal_domain</span><span class="o">=</span><span class="n">internal_domain</span><span class="p">,</span>
            <span class="n">user_domain</span><span class="o">=</span><span class="n">user_domain</span><span class="p">,</span>
            <span class="n">grid</span><span class="o">=</span><span class="n">grd</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="c1"># The instance has no coefficients</span>
        <span class="k">return</span> <span class="n">origin_poly</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">multi_index</span><span class="o">=</span><span class="n">mi</span><span class="p">,</span>
            <span class="n">coeffs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">internal_domain</span><span class="o">=</span><span class="n">internal_domain</span><span class="p">,</span>
            <span class="n">user_domain</span><span class="o">=</span><span class="n">user_domain</span><span class="p">,</span>
            <span class="n">grid</span><span class="o">=</span><span class="n">grd</span><span class="p">,</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">_expand_dim_to_target_dim</span><span class="p">(</span>
    <span class="n">origin_poly</span><span class="p">:</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">,</span>
    <span class="n">target_dimension</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">extra_internal_domain</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">extra_user_domain</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MultivariatePolynomialSingleABC&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Expand the dimension of the polynomial to the target dimension.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    origin_poly : MultivariatePolynomialSingleABC</span>
<span class="sd">        The polynomial whose spatial dimension is to be expanded.</span>
<span class="sd">    target_dimension : int</span>
<span class="sd">        The target dimension to which the given polynomial will be expanded.</span>
<span class="sd">    extra_internal_domain : :class:`numpy:numpy.ndarray`, optional</span>
<span class="sd">        The additional internal domains for the expanded dimensions.</span>
<span class="sd">    extra_user_domain : :class:`numpy:numpy.ndarray`, optional</span>
<span class="sd">        The additional user domains for the expanded dimensions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    MultivariatePolynomialSingleABC</span>
<span class="sd">        A new instance of polynomial with an expanded dimension.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If ``extra_internal_domain`` and ``extra_user_domain`` are both</span>
<span class="sd">        ``None`` and the domains of the origin polynomial are not uniform</span>
<span class="sd">        such that the domains cannot be extrapolated to higher dimension.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">origin_poly</span><span class="o">.</span><span class="n">spatial_dimension</span> <span class="o">==</span> <span class="n">target_dimension</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">copy</span><span class="p">(</span><span class="n">origin_poly</span><span class="p">)</span>

    <span class="c1"># Expand the underlying multi-index set</span>
    <span class="n">mi</span> <span class="o">=</span> <span class="n">origin_poly</span><span class="o">.</span><span class="n">multi_index</span><span class="o">.</span><span class="n">expand_dim</span><span class="p">(</span><span class="n">target_dimension</span><span class="p">)</span>

    <span class="c1"># Expand the dimension of the underlying grid</span>
    <span class="n">grd</span> <span class="o">=</span> <span class="n">origin_poly</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">expand_dim</span><span class="p">(</span><span class="n">target_dimension</span><span class="p">)</span>

    <span class="c1"># Expand the dimension of the internal domain</span>
    <span class="n">origin_internal_domain</span> <span class="o">=</span> <span class="n">origin_poly</span><span class="o">.</span><span class="n">internal_domain</span>
    <span class="n">target_internal_domain</span> <span class="o">=</span> <span class="n">_expand_domain</span><span class="p">(</span>
        <span class="n">origin_internal_domain</span><span class="p">,</span>
        <span class="n">target_dimension</span><span class="p">,</span>
        <span class="n">extra_internal_domain</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Expand the dimension of the user domain</span>
    <span class="n">origin_user_domain</span> <span class="o">=</span> <span class="n">origin_poly</span><span class="o">.</span><span class="n">user_domain</span>
    <span class="n">target_user_domain</span> <span class="o">=</span> <span class="n">_expand_domain</span><span class="p">(</span>
        <span class="n">origin_user_domain</span><span class="p">,</span>
        <span class="n">target_dimension</span><span class="p">,</span>
        <span class="n">extra_user_domain</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Return a new instance</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># The instance is initialized with coefficients</span>
        <span class="k">return</span> <span class="n">origin_poly</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">multi_index</span><span class="o">=</span><span class="n">mi</span><span class="p">,</span>
            <span class="n">coeffs</span><span class="o">=</span><span class="n">origin_poly</span><span class="o">.</span><span class="n">coeffs</span><span class="p">,</span>
            <span class="n">internal_domain</span><span class="o">=</span><span class="n">target_internal_domain</span><span class="p">,</span>
            <span class="n">user_domain</span><span class="o">=</span><span class="n">target_user_domain</span><span class="p">,</span>
            <span class="n">grid</span><span class="o">=</span><span class="n">grd</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="c1"># The instance has no coefficients</span>
        <span class="k">return</span> <span class="n">origin_poly</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">multi_index</span><span class="o">=</span><span class="n">mi</span><span class="p">,</span>
            <span class="n">coeffs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">internal_domain</span><span class="o">=</span><span class="n">target_internal_domain</span><span class="p">,</span>
            <span class="n">user_domain</span><span class="o">=</span><span class="n">target_user_domain</span><span class="p">,</span>
            <span class="n">grid</span><span class="o">=</span><span class="n">grd</span><span class="p">,</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">_is_domain_uniform</span><span class="p">(</span><span class="n">domain</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if a given domain is non-uniform&quot;&quot;&quot;</span>
    <span class="n">lb_uniform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">ub_uniform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">lb_uniform</span> <span class="ow">and</span> <span class="n">ub_uniform</span>


<span class="k">def</span> <span class="nf">_expand_domain</span><span class="p">(</span>
    <span class="n">origin_domain</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">target_dimension</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">extra_domain</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Append additional polynomial domains to the origin domain column-wise.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    origin_domain : :class:`numpy:numpy.ndarray`</span>
<span class="sd">        The origin polynomial domain to be expanded.</span>
<span class="sd">    target_dimension : int</span>
<span class="sd">        The target spatial dimension to which the given polynomial</span>
<span class="sd">        will be expanded.</span>
<span class="sd">    extra_domain : :class:`numpy:numpy.ndarray`, optional</span>
<span class="sd">        The additional domain to be added to form the target domain.</span>
<span class="sd">        This parameter is optional, if `None` is provided, the domain can only</span>
<span class="sd">        be expanded if ``origin_domain`` is uniform.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the spatial dimension difference</span>
    <span class="n">origin_dimension</span> <span class="o">=</span> <span class="n">origin_domain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">diff_dimension</span> <span class="o">=</span> <span class="n">target_dimension</span> <span class="o">-</span> <span class="n">origin_dimension</span>

    <span class="c1"># If no extra domain is provided</span>
    <span class="k">if</span> <span class="n">extra_domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">_is_domain_uniform</span><span class="p">(</span><span class="n">origin_domain</span><span class="p">):</span>
            <span class="n">extra_domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                <span class="n">origin_domain</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                <span class="n">repeats</span><span class="o">=</span><span class="n">diff_dimension</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Non-uniform domain cannot be extrapolated &quot;</span>
                <span class="s2">&quot;for dimension expansion&quot;</span>
            <span class="p">)</span>
    <span class="c1"># Combine the extra domain</span>
    <span class="n">target_domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">origin_domain</span><span class="p">,</span> <span class="n">extra_domain</span><span class="p">]</span>
    <span class="c1"># Verify the resulting domain</span>
    <span class="n">target_domain</span> <span class="o">=</span> <span class="n">verify_poly_domain</span><span class="p">(</span><span class="n">target_domain</span><span class="p">,</span> <span class="n">target_dimension</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">target_domain</span>
</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2022, Minterpy Development Team.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>